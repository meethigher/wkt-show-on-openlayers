import{F as t}from"./ef66d3-BW2MARdE.js";function s(t,s){return t.interfaces_&&t.interfaces_.indexOf(s)>-1}class i{static equalsWithTolerance(t,s,i){return Math.abs(t-s)<=i}}class e extends Error{constructor(t){super(t),this.name=Object.keys({Exception:e})[0]}toString(){return this.message}}class n extends e{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:n})[0]}}class r{constructor(t,s){this.low=s||0,this.high=t||0}static toBinaryString(t){let s,i="";for(s=2147483648;s>0;s>>>=1)i+=(t.high&s)===s?"1":"0";for(s=2147483648;s>0;s>>>=1)i+=(t.low&s)===s?"1":"0";return i}}function h(){}function o(){}function u(){}h.NaN=NaN,h.isNaN=t=>Number.isNaN(t),h.isInfinite=t=>!Number.isFinite(t),h.MAX_VALUE=Number.MAX_VALUE,h.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,h.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,s=new Float64Array(1),i=new Int32Array(s.buffer);h.doubleToLongBits=function(e){s[0]=e;let n=0|i[0],h=0|i[1];return(h&t)===t&&1048575&h&&0!==n&&(n=0,h=2146959360),new r(h,n)},h.longBitsToDouble=function(t){return i[0]=t.low,i[1]=t.high,s[0]}}():function(){const t=Math.log2,s=Math.floor,i=Math.pow,e=function(){for(let e=53;e>0;e--){const n=i(2,e)-1;if(s(t(n))+1===e)return n}return 0}();h.doubleToLongBits=function(n){let h,o,u,l,c,a,f,d,g;if(n<0||1/n===Number.NEGATIVE_INFINITY?(a=1<<31,n=-n):a=0,0===n)return g=0,d=a,new r(d,g);if(n===1/0)return g=0,d=2146435072|a,new r(d,g);if(n!=n)return g=0,d=2146959360,new r(d,g);if(l=0,g=0,h=s(n),h>1)if(h<=e)l=s(t(h)),l<=20?(g=0,d=h<<20-l&1048575):(u=l-20,o=i(2,u),g=h%o<<32-u,d=h/o&1048575);else for(u=h,g=0;o=u/2,u=s(o),0!==u;)l++,g>>>=1,g|=(1&d)<<31,d>>>=1,o!==u&&(d|=524288);if(f=l+1023,c=0===h,h=n-h,l<52&&0!==h)for(u=0;;){if(o=2*h,o>=1?(h=o-1,c?(f--,c=!1):(u<<=1,u|=1,l++)):(h=o,c?0===--f&&(l++,c=!1):(u<<=1,l++)),20===l)d|=u,u=0;else if(52===l){g|=u;break}if(1===o){l<20?d|=u<<20-l:l<52&&(g|=u<<52-l);break}}return d|=f<<20,d|=a,new r(d,g)},h.longBitsToDouble=function(t){let s,e,n,r;const h=t.high,o=t.low,u=h&1<<31?-1:1;for(n=((2146435072&h)>>20)-1023,r=0,e=1<<19,s=1;s<=20;s++)h&e&&(r+=i(2,-s)),e>>>=1;for(e=1<<31,s=21;s<=52;s++)o&e&&(r+=i(2,-s)),e>>>=1;if(-1023===n){if(0===r)return 0*u;n=-1022}else{if(1024===n)return 0===r?u/0:NaN;r+=1}return u*r*i(2,n)}}();class l extends e{constructor(t){super(t),this.name=Object.keys({RuntimeException:l})[0]}}class c extends l{constructor(){super(),c.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)l.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];l.constructor_.call(this,t)}}}class a{static isTrue(){if(1===arguments.length){const t=arguments[0];a.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new c:new c(t)}}static shouldNeverReachHere(){if(0===arguments.length)a.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}}static equals(){if(2===arguments.length){const t=arguments[0],s=arguments[1];a.equals(t,s,null)}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];if(!s.equals(t))throw new c("Expected "+t+" but encountered "+s+(null!==i?": "+i:""))}}}function f(){}function d(){}const g=new ArrayBuffer(8),w=new Float64Array(g),p=new Int32Array(g);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],s=arguments[1];m.constructor_.call(this,t,s,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.x=t,this.y=s,this.z=i}}static hashCode(t){return w[0]=t,p[0]^p[1]}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],s=arguments[1];return!!i.equalsWithTolerance(this.x,t.x,s)&&!!i.equalsWithTolerance(this.y,t.y,s)}}setM(t){throw new n("Invalid ordinate index: "+m.M)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||h.isNaN(this.getZ())&&h.isNaN(t.getZ()))}setX(t){this.x=t}compareTo(t){const s=t;return this.x<s.x?-1:this.x>s.x?1:this.y<s.y?-1:this.y>s.y?1:0}getX(){return this.x}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const s=this.x-t.x,i=this.y-t.y,e=this.getZ()-t.getZ();return Math.sqrt(s*s+i*i+e*e)}getY(){return this.y}getM(){return h.NaN}setOrdinate(t,s){switch(t){case m.X:this.x=s;break;case m.Y:this.y=s;break;case m.Z:this.setZ(s);break;default:throw new n("Invalid ordinate index: "+t)}}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new n("Invalid ordinate index: "+t)}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,s){return i.equalsWithTolerance(this.getZ(),t.getZ(),s)}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return a.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}setY(t){this.y=t}distance(t){const s=this.x-t.x,i=this.y-t.y;return Math.sqrt(s*s+i*i)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,f,u]}}class y{constructor(){y.constructor_.apply(this,arguments)}static constructor_(){if(this.t=2,0===arguments.length)y.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this.t=t}}static compare(t,s){return t<s?-1:t>s?1:h.isNaN(t)?h.isNaN(s)?0:-1:h.isNaN(s)?1:0}compare(t,s){const i=y.compare(t.x,s.x);if(0!==i)return i;const e=y.compare(t.y,s.y);return 0!==e?e:this.t<=2?0:y.compare(t.getZ(),s.getZ())}get interfaces_(){return[d]}}m.DimensionalComparator=y,m.NULL_ORDINATE=h.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class b{static ofLine(t){const s=t.size();if(s<=1)return 0;let i=0;const e=new m;t.getCoordinate(0,e);let n=e.x,r=e.y;for(let h=1;h<s;h++){t.getCoordinate(h,e);const s=e.x,o=e.y,u=s-n,l=o-r;i+=Math.sqrt(u*u+l*l),n=s,r=o}return i}}class I{filter(t){}}class E extends e{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:E})[0]}}class M{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class N extends e{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:N})[0]}}class x extends M{get(){}set(){}isEmpty(){}}class A extends e{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:A})[0]}}class C extends x{constructor(t){super(),this.array=[],t instanceof M&&this.addAll(t)}get interfaces_(){return[x,M]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const s of t)this.array.push(s)}set(t,s){const i=this.array[t];return this.array[t]=s,i}iterator(){return new S(this)}get(t){if(t<0||t>=this.size())throw new N;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort((s,i)=>t.compare(s,i)):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let s=0,i=this.array.length;s<i;s++)if(this.array[s]===t)return!!this.array.splice(s,1);return!1}[Symbol.iterator](){return this.array.values()}}let S=class{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new A;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}};class _ extends C{constructor(){super(),_.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.ensureCapacity(t.length),this.add(t,s)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&s(arguments[0],M)){const t=arguments[1];let s=!1;for(let i=arguments[0].iterator();i.hasNext();)this.add(i.next(),t),s=!0;return s}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let s=0;s<this.size();s++)t.add(s,this.get(s).clone());return t}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}toCoordinateArray(){if(0===arguments.length)return this.toArray(_.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(_.coordArrayType);const t=this.size(),s=new Array(t).fill(null);for(let i=0;i<t;i++)s[i]=this.get(t-i-1);return s}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],s=arguments[1];return this.add(t,s,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(t))return null;super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],s=arguments[1];return this.add(t,s),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],s=arguments[1];if(arguments[2])for(let i=0;i<t.length;i++)this.add(t[i],s);else for(let i=t.length-1;i>=0;i--)this.add(t[i],s);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],s=arguments[1];if(!arguments[2]){const i=this.size();if(i>0){if(t>0&&this.get(t-1).equals2D(s))return null;if(t<i&&this.get(t).equals2D(s))return null}}super.add.call(this,t,s)}}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];let n=1;i>e&&(n=-1);for(let r=i;r!==e;r+=n)this.add(t[r],s);return!0}}}_.coordArrayType=new Array(0).fill(null);class L extends m{constructor(){super(),L.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof L){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];m.constructor_.call(this,t,s,m.NULL_ORDINATE)}}setOrdinate(t,s){switch(t){case L.X:this.x=s;break;case L.Y:this.y=s;break;default:throw new n("Invalid ordinate index: "+t)}}setZ(t){throw new n("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new L(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case L.X:return this.x;case L.Y:return this.y}throw new n("Invalid ordinate index: "+t)}}L.X=0,L.Y=1,L.Z=-1,L.M=-1;class v extends m{constructor(){super(),v.constructor_.apply(this,arguments)}static constructor_(){if(this.i=null,0===arguments.length)m.constructor_.call(this),this.i=0;else if(1===arguments.length){if(arguments[0]instanceof v){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this.i=t.i}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this.i=this.getM()}}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];m.constructor_.call(this,t,s,m.NULL_ORDINATE),this.i=i}}setM(t){this.i=t}setZ(t){throw new n("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new v(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this.i=t.getM()}getM(){return this.i}setOrdinate(t,s){switch(t){case v.X:this.x=s;break;case v.Y:this.y=s;break;case v.M:this.i=s;break;default:throw new n("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case v.X:return this.x;case v.Y:return this.y;case v.M:return this.i}throw new n("Invalid ordinate index: "+t)}}v.X=0,v.Y=1,v.Z=-1,v.M=2;class P extends m{constructor(){super(),P.constructor_.apply(this,arguments)}static constructor_(){if(this.i=null,0===arguments.length)m.constructor_.call(this),this.i=0;else if(1===arguments.length){if(arguments[0]instanceof P){const t=arguments[0];m.constructor_.call(this,t),this.i=t.i}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this.i=this.getM()}}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];m.constructor_.call(this,t,s,i),this.i=e}}setM(t){this.i=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new n("Invalid ordinate index: "+t)}copy(){return new P(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this.i=t.getM()}getM(){return this.i}setOrdinate(t,s){switch(t){case m.X:this.x=s;break;case m.Y:this.y=s;break;case m.Z:this.z=s;break;case m.M:this.i=s;break;default:throw new n("Invalid ordinate index: "+t)}}}class D{static measures(t){return t instanceof L?0:t instanceof v||t instanceof P?1:0}static create(){if(1===arguments.length){const t=arguments[0];return D.create(t,0)}if(2===arguments.length){const t=arguments[0],s=arguments[1];return 2===t?new L:3===t&&0===s?new m:3===t&&1===s?new v:4===t&&1===s?new P:new m}}static dimension(t){return t instanceof L?2:t instanceof v?3:t instanceof P?4:3}}class R{static log10(t){const s=Math.log(t);return h.isInfinite(s)||h.isNaN(s)?s:s/R.LOG_10}static min(t,s,i,e){let n=t;return s<n&&(n=s),i<n&&(n=i),e<n&&(n=e),n}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],s=arguments[1],i=arguments[2];return t<s?s:t>i?i:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1],i=arguments[2];return t<s?s:t>i?i:t}}static average(t,s){return(t+s)/2}static wrap(t,s){return t<0?s- -t%s:t%s}static max(){if(3===arguments.length){const t=arguments[1],s=arguments[2];let i=arguments[0];return t>i&&(i=t),s>i&&(i=s),i}if(4===arguments.length){const t=arguments[1],s=arguments[2],i=arguments[3];let e=arguments[0];return t>e&&(e=t),s>e&&(e=s),i>e&&(e=i),e}}}R.LOG_10=Math.log(10);class T{static arraycopy(t,s,i,e,n){let r=0;for(let h=s;h<s+n;h++)i[e+r]=t[h],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this.h=null,this.o=null,this.u=null,this.l=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.init(t.x,s.x,t.y,s.y)}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];this.init(t,s,i,e)}}static intersects(){if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];return i.x>=(t.x<s.x?t.x:s.x)&&i.x<=(t.x>s.x?t.x:s.x)&&i.y>=(t.y<s.y?t.y:s.y)&&i.y<=(t.y>s.y?t.y:s.y)}if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];let n=Math.min(i.x,e.x),r=Math.max(i.x,e.x),h=Math.min(t.x,s.x),o=Math.max(t.x,s.x);return!(h>r||o<n||(n=Math.min(i.y,e.y),r=Math.max(i.y,e.y),h=Math.min(t.y,s.y),o=Math.max(t.y,s.y),h>r||o<n))}}getArea(){return this.getWidth()*this.getHeight()}getMinX(){return this.h}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this.h=t.getMinX(),this.o=t.getMaxX(),this.u=t.getMinY(),this.l=t.getMaxY()):(t.h<this.h&&(this.h=t.h),t.o>this.o&&(this.o=t.o),t.u<this.u&&(this.u=t.u),t.l>this.l&&(this.l=t.l))}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.isNull()?(this.h=t,this.o=t,this.u=s,this.l=s):(t<this.h&&(this.h=t),t>this.o&&(this.o=t),s<this.u&&(this.u=s),s>this.l&&(this.l=s))}}compareTo(t){const s=t;return this.isNull()?s.isNull()?0:-1:s.isNull()?1:this.h<s.h?-1:this.h>s.h?1:this.u<s.u?-1:this.u>s.u?1:this.o<s.o?-1:this.o>s.o?1:this.l<s.l?-1:this.l>s.l?1:0}translate(t,s){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+s,this.getMaxY()+s)}copy(){return new O(this)}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];if(this.isNull())return null;this.h-=t,this.o+=t,this.u-=s,this.l+=s,(this.h>this.o||this.u>this.l)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.covers(t,s)}}hashCode(){let t=17;return t=37*t+m.hashCode(this.h),t=37*t+m.hashCode(this.o),t=37*t+m.hashCode(this.u),t=37*t+m.hashCode(this.l),t}equals(t){if(!(t instanceof O))return!1;const s=t;return this.isNull()?s.isNull():this.o===s.getMaxX()&&this.l===s.getMaxY()&&this.h===s.getMinX()&&this.u===s.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const s=this.h>t.h?this.h:t.h,i=this.u>t.u?this.u:t.u,e=this.o<t.o?this.o:t.o,n=this.l<t.l?this.l:t.l;return new O(s,e,i,n)}isNull(){return this.o<this.h}getMaxX(){return this.o}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&t.getMinX()>=this.h&&t.getMaxX()<=this.o&&t.getMinY()>=this.u&&t.getMaxY()<=this.l}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];return!this.isNull()&&t>=this.h&&t<=this.o&&s>=this.u&&s<=this.l}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t.h>this.o||t.o<this.h||t.u>this.l||t.l<this.u)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],s=arguments[1];return!(this.isNull()||(t.x<s.x?t.x:s.x)>this.o||(t.x>s.x?t.x:s.x)<this.h||(t.y<s.y?t.y:s.y)>this.l||(t.y>s.y?t.y:s.y)<this.u)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],s=arguments[1];return!this.isNull()&&!(t>this.o||t<this.h||s>this.l||s<this.u)}}}getMinY(){return this.u}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),s=this.getHeight();return Math.sqrt(t*t+s*s)}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),s=this.getHeight();return t<s?t:s}getWidth(){return this.isNull()?0:this.o-this.h}toString(){return"Env["+this.h+" : "+this.o+", "+this.u+" : "+this.l+"]"}setToNull(){this.h=0,this.o=-1,this.u=0,this.l=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||t.h>this.o||t.o<this.h||t.u>this.l||t.l<this.u}getHeight(){return this.isNull()?0:this.l-this.u}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),s=this.getHeight();return t>s?t:s}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.h=t.h,this.o=t.o,this.u=t.u,this.l=t.l}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.init(t.x,s.x,t.y,s.y)}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];t<s?(this.h=t,this.o=s):(this.h=s,this.o=t),i<e?(this.u=i,this.l=e):(this.u=e,this.l=i)}}getMaxY(){return this.l}distance(t){if(this.intersects(t))return 0;let s=0;this.o<t.h?s=t.h-this.o:this.h>t.o&&(s=this.h-t.o);let i=0;return this.l<t.u?i=t.u-this.l:this.u>t.l&&(i=this.u-t.l),0===s?i:0===i?s:Math.sqrt(s*s+i*i)}get interfaces_(){return[o,u]}}class k{static scroll(t,s){const i=k.indexOf(s,t);if(i<0)return null;const e=new Array(t.length).fill(null);T.arraycopy(t,i,e,0,t.length-i),T.arraycopy(t,0,e,t.length-i,i),T.arraycopy(e,0,t,0,t.length)}static removeRepeatedPoints(t){return k.hasRepeatedPoints(t)?new _(t,!1).toCoordinateArray():t}static reverse(t){const s=t.length-1,i=Math.trunc(s/2);for(let e=0;e<=i;e++){const i=t[e];t[e]=t[s-e],t[s-e]=i}}static removeNull(t){let s=0;for(let n=0;n<t.length;n++)null!==t[n]&&s++;const i=new Array(s).fill(null);if(0===s)return i;let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&(i[e++]=t[n]);return i}static copyDeep(){if(1===arguments.length){const t=arguments[0],s=new Array(t.length).fill(null);for(let i=0;i<t.length;i++)s[i]=t[i].copy();return s}if(5===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3],n=arguments[4];for(let r=0;r<n;r++)i[e+r]=t[s+r].copy()}}static isEqualReversed(t,s){for(let i=0;i<t.length;i++){const e=t[i],n=s[t.length-i-1];if(0!==e.compareTo(n))return!1}return!0}static envelope(t){const s=new O;for(let i=0;i<t.length;i++)s.expandToInclude(t[i]);return s}static extract(t,s,i){s=R.clamp(s,0,t.length);let e=(i=R.clamp(i,-1,t.length))-s+1;i<0&&(e=0),s>=t.length&&(e=0),i<s&&(e=0);const n=new Array(e).fill(null);if(0===e)return n;let r=0;for(let h=s;h<=i;h++)n[r++]=t[h];return n}static isRing(t){return!(t.length<4||!t[0].equals2D(t[t.length-1]))}static ptNotInList(t,s){for(let i=0;i<t.length;i++){const e=t[i];if(k.indexOf(e,s)<0)return e}return null}static equals(){if(2===arguments.length){const t=arguments[0],s=arguments[1];if(t===s)return!0;if(null===t||null===s)return!1;if(t.length!==s.length)return!1;for(let i=0;i<t.length;i++)if(!t[i].equals(s[i]))return!1;return!0}if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];if(t===s)return!0;if(null===t||null===s)return!1;if(t.length!==s.length)return!1;for(let e=0;e<t.length;e++)if(0!==i.compare(t[e],s[e]))return!1;return!0}}static intersection(t,s){const i=new _;for(let e=0;e<t.length;e++)s.intersects(t[e])&&i.add(t[e],!0);return i.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let s=0;for(const i of t)s=Math.max(s,D.measures(i));return s}static hasRepeatedPoints(t){for(let s=1;s<t.length;s++)if(t[s-1].equals(t[s]))return!0;return!1}static toCoordinateArray(t){return t.toArray(k.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let s=0;for(const i of t)s=Math.max(s,D.dimension(i));return s}static atLeastNCoordinatesOrNothing(t,s){return s.length>=t?s:[]}static indexOf(t,s){for(let i=0;i<s.length;i++)if(t.equals(s[i]))return i;return-1}static increasingDirection(t){for(let s=0;s<Math.trunc(t.length/2);s++){const i=t.length-1-s,e=t[s].compareTo(t[i]);if(0!==e)return e}return 1}static compare(t,s){let i=0;for(;i<t.length&&i<s.length;){const e=t[i].compareTo(s[i]);if(0!==e)return e;i++}return i<s.length?-1:i<t.length?1:0}static minCoordinate(t){let s=null;for(let i=0;i<t.length;i++)(null===s||s.compareTo(t[i])>0)&&(s=t[i]);return s}}k.ForwardComparator=class{compare(t,s){const i=t,e=s;return k.compare(i,e)}get interfaces_(){return[d]}},k.BidirectionalComparator=class{compare(t,s){const i=t,e=s;if(i.length<e.length)return-1;if(i.length>e.length)return 1;if(0===i.length)return 0;const n=k.compare(i,e);return k.isEqualReversed(i,e)?0:n}OLDcompare(t,s){const i=t,e=s;if(i.length<e.length)return-1;if(i.length>e.length)return 1;if(0===i.length)return 0;const n=k.increasingDirection(i),r=k.increasingDirection(e);let h=n>0?0:i.length-1,o=r>0?0:i.length-1;for(let u=0;u<i.length;u++){const t=i[h].compareTo(e[o]);if(0!==t)return t;h+=n,o+=r}return 0}get interfaces_(){return[d]}},k.coordArrayType=new Array(0).fill(null);class q{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class B{static toDimensionSymbol(t){switch(t){case B.FALSE:return B.SYM_FALSE;case B.TRUE:return B.SYM_TRUE;case B.DONTCARE:return B.SYM_DONTCARE;case B.P:return B.SYM_P;case B.L:return B.SYM_L;case B.A:return B.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(q.toUpperCase(t)){case B.SYM_FALSE:return B.FALSE;case B.SYM_TRUE:return B.TRUE;case B.SYM_DONTCARE:return B.DONTCARE;case B.SYM_P:return B.P;case B.SYM_L:return B.L;case B.SYM_A:return B.A}throw new n("Unknown dimension symbol: "+t)}}B.P=0,B.L=1,B.A=2,B.FALSE=-1,B.TRUE=-2,B.DONTCARE=-3,B.SYM_FALSE="F",B.SYM_TRUE="T",B.SYM_DONTCARE="*",B.SYM_P="0",B.SYM_L="1",B.SYM_A="2";class G{constructor(){G.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===G.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this.p}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(G.geometryChangedFilter)}geometryChangedAction(){this.I=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const s=arguments[0];return t=s,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(s)}if(2===arguments.length){const s=arguments[0],i=arguments[1];return t=s,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(s,i)}}getUserData(){return this.N}getSRID(){return this.C}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===G.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,s,i){return 0===i?t.equals(s):t.distance(s)<=i}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this.I?null:this.I.copy(),t.C=this.C,t.N=this.N,t}getPrecisionModel(){return this.p.getPrecisionModel()}getEnvelopeInternal(){return null===this.I&&(this.I=this.computeEnvelopeInternal()),new O(this.I)}setSRID(t){this.C=t}setUserData(t){this.N=t}compare(t,s){const i=t.iterator(),e=s.iterator();for(;i.hasNext()&&e.hasNext();){const t=i.next(),s=e.next(),n=t.compareTo(s);if(0!==n)return n}return i.hasNext()?1:e.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[f,o,u]}getClass(){return G}static hasNonEmptyElements(t){for(let s=0;s<t.length;s++)if(!t[s].isEmpty())return!0;return!1}static hasNullElements(t){for(let s=0;s<t.length;s++)if(null===t[s])return!0;return!1}}G.constructor_=function(t){t&&(this.I=null,this.N=null,this.p=t,this.C=t.getSRID())},G.TYPECODE_POINT=0,G.TYPECODE_MULTIPOINT=1,G.TYPECODE_LINESTRING=2,G.TYPECODE_LINEARRING=3,G.TYPECODE_MULTILINESTRING=4,G.TYPECODE_POLYGON=5,G.TYPECODE_MULTIPOLYGON=6,G.TYPECODE_GEOMETRYCOLLECTION=7,G.TYPENAME_POINT="Point",G.TYPENAME_MULTIPOINT="MultiPoint",G.TYPENAME_LINESTRING="LineString",G.TYPENAME_LINEARRING="LinearRing",G.TYPENAME_MULTILINESTRING="MultiLineString",G.TYPENAME_POLYGON="Polygon",G.TYPENAME_MULTIPOLYGON="MultiPolygon",G.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",G.geometryChangedFilter={get interfaces_(){return[I]},filter(t){t.geometryChangedAction()}};class F{filter(t){}}class z{}class V{getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getM(t){if(this.hasM()){const s=this.getDimension()-this.getMeasures();return this.getOrdinate(t,s)}return h.NaN}setOrdinate(t,s,i){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):h.NaN}size(){}getOrdinate(t,s){}get interfaces_(){return[f]}}V.X=0,V.Y=1,V.Z=2,V.M=3;class Y{static scroll(){if(2===arguments.length){if(s(arguments[0],V)&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1];Y.scroll(t,s,Y.isRing(t))}else if(s(arguments[0],V)&&arguments[1]instanceof m){const t=arguments[0],s=arguments[1],i=Y.indexOf(s,t);if(i<=0)return null;Y.scroll(t,i)}}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];if(s<=0)return null;const e=t.copy(),n=i?t.size()-1:t.size();for(let r=0;r<n;r++)for(let i=0;i<t.getDimension();i++)t.setOrdinate(r,i,e.getOrdinate((s+r)%n,i));if(i)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,t.getOrdinate(0,r))}}static isEqual(t,s){const i=t.size();if(i!==s.size())return!1;const e=Math.min(t.getDimension(),s.getDimension());for(let n=0;n<i;n++)for(let i=0;i<e;i++){const e=t.getOrdinate(n,i),r=s.getOrdinate(n,i);if(!(t.getOrdinate(n,i)===s.getOrdinate(n,i)||h.isNaN(e)&&h.isNaN(r)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return Y.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],s=arguments[2];let i=-1,e=null;for(let n=arguments[1];n<=s;n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s,i=n)}return i}}static extend(t,s,i){const e=t.create(i,s.getDimension()),n=s.size();if(Y.copy(s,0,e,0,n),n>0)for(let r=n;r<i;r++)Y.copy(s,n-1,e,r,1);return e}static reverse(t){const s=t.size()-1,i=Math.trunc(s/2);for(let e=0;e<=i;e++)Y.swap(t,e,s-e)}static ensureValidRing(t,s){const i=s.size();return 0===i?s:i<=3?Y.createClosedRing(t,s,4):s.getOrdinate(0,V.X)===s.getOrdinate(i-1,V.X)&&s.getOrdinate(0,V.Y)===s.getOrdinate(i-1,V.Y)?s:Y.createClosedRing(t,s,i+1)}static minCoordinate(t){let s=null;for(let i=0;i<t.size();i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e)}return s}static copyCoord(t,s,i,e){const n=Math.min(t.getDimension(),i.getDimension());for(let r=0;r<n;r++)i.setOrdinate(e,r,t.getOrdinate(s,r))}static isRing(t){const s=t.size();return 0===s||!(s<=3)&&t.getOrdinate(0,V.X)===t.getOrdinate(s-1,V.X)&&t.getOrdinate(0,V.Y)===t.getOrdinate(s-1,V.Y)}static swap(t,s,i){if(s===i)return null;for(let e=0;e<t.getDimension();e++){const n=t.getOrdinate(s,e);t.setOrdinate(s,e,t.getOrdinate(i,e)),t.setOrdinate(i,e,n)}}static copy(t,s,i,e,n){for(let r=0;r<n;r++)Y.copyCoord(t,s+r,i,e+r)}static indexOf(t,s){for(let i=0;i<s.size();i++)if(t.x===s.getOrdinate(i,V.X)&&t.y===s.getOrdinate(i,V.Y))return i;return-1}static createClosedRing(t,s,i){const e=t.create(i,s.getDimension()),n=s.size();Y.copy(s,0,e,0,n);for(let r=n;r<i;r++)Y.copy(s,0,e,r,1);return e}}class j{filter(t){}}class X{filter(t,s){}isGeometryChanged(){}isDone(){}}class U extends G{constructor(){super(),U.constructor_.apply(this,arguments)}static constructor_(){if(this.S=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],s=arguments[1];G.constructor_.call(this,s),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this.S.expandEnvelope(new O)}isRing(){return this.isClosed()&&k.isRing(this.getCoordinates())}getCoordinates(){return this.S.toCoordinateArray()}copyInternal(){return new U(this.S.copy(),this.p)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];if(!this.isEquivalentClass(t))return!1;const i=t;if(this.S.size()!==i.S.size())return!1;for(let e=0;e<this.S.size();e++)if(!this.equal(this.S.getCoordinate(e),i.S.getCoordinate(e),s))return!1;return!0}return super.equalsExact.apply(this,arguments)}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this.S.copy();return Y.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return G.TYPECODE_LINESTRING}getDimension(){return 1}getBoundary(){throw new E}isEquivalentClass(t){return t instanceof U}getCoordinateSequence(){return this.S}getPointN(t){return this.getFactory().createPoint(this.S.getCoordinate(t))}normalize(){for(let t=0;t<Math.trunc(this.S.size()/2);t++){const s=this.S.size()-1-t;if(!this.S.getCoordinate(t).equals(this.S.getCoordinate(s))){if(this.S.getCoordinate(t).compareTo(this.S.getCoordinate(s))>0){const t=this.S.copy();Y.reverse(t),this.S=t}return null}}}getCoordinate(){return this.isEmpty()?null:this.S.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?B.FALSE:0}getLength(){return b.ofLine(this.S)}getNumPoints(){return this.S.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let s=0,i=0;for(;s<this.S.size()&&i<t.S.size();){const e=this.S.getCoordinate(s).compareTo(t.S.getCoordinate(i));if(0!==e)return e;s++,i++}return s<this.S.size()?1:i<t.S.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this.S,t.S)}}apply(){if(s(arguments[0],F)){const t=arguments[0];for(let s=0;s<this.S.size();s++)t.filter(this.S.getCoordinate(s))}else if(s(arguments[0],X)){const t=arguments[0];if(0===this.S.size())return null;for(let s=0;s<this.S.size()&&(t.filter(this.S,s),!t.isDone());s++);t.isGeometryChanged()&&this.geometryChanged()}else(s(arguments[0],j)||s(arguments[0],I))&&arguments[0].filter(this)}getCoordinateN(t){return this.S.getCoordinate(t)}getGeometryType(){return G.TYPENAME_LINESTRING}isEmpty(){return 0===this.S.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.S=t}isCoordinate(t){for(let s=0;s<this.S.size();s++)if(this.S.getCoordinate(s).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}get interfaces_(){return[z]}}class Z extends U{constructor(){super(),Z.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];U.constructor_.call(this,t,s),this.validateConstruction()}copyInternal(){return new Z(this.S.copy(),this.p)}getBoundaryDimension(){return B.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this.S.copy();return Y.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return G.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Z.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return G.TYPENAME_LINEARRING}}Z.MINIMUM_VALID_SIZE=4;class H{create(){if(1===arguments.length)arguments[0]instanceof Array||s(arguments[0],V);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],s=arguments[1];return this.create(t,s)}}}class W{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,s){this.str=this.str.substr(0,t)+s+this.str.substr(t+1)}toString(){return this.str}}class K{constructor(){K.constructor_.apply(this,arguments)}static constructor_(){if(this._=3,this.v=0,this.D=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];K.constructor_.call(this,t,k.dimension(t),k.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.D=new Array(t).fill(null);for(let s=0;s<t;s++)this.D[s]=new m}else if(s(arguments[0],V)){const t=arguments[0];if(null===t)return this.D=new Array(0).fill(null),null;this._=t.getDimension(),this.v=t.getMeasures(),this.D=new Array(t.size()).fill(null);for(let s=0;s<this.D.length;s++)this.D[s]=t.getCoordinateCopy(s)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1];K.constructor_.call(this,t,s,k.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1];this.D=new Array(t).fill(null),this._=s;for(let i=0;i<t;i++)this.D[i]=D.create(s)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1],i=arguments[2];this._=s,this.v=i,this.D=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],s=arguments[1],i=arguments[2];this.D=new Array(t).fill(null),this._=s,this.v=i;for(let e=0;e<t;e++)this.D[e]=this.createCoordinate()}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this.D[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this.D[t])}}getCoordinateCopy(t){const s=this.createCoordinate();return s.setCoordinate(this.D[t]),s}createCoordinate(){return D.create(this.getDimension(),this.getMeasures())}getDimension(){return this._}getX(t){return this.D[t].x}getMeasures(){return this.v}expandEnvelope(t){for(let s=0;s<this.D.length;s++)t.expandToInclude(this.D[s]);return t}copy(){const t=new Array(this.size()).fill(null);for(let s=0;s<this.D.length;s++){const i=this.createCoordinate();i.setCoordinate(this.D[s]),t[s]=i}return new K(t,this._,this.v)}toString(){if(this.D.length>0){const t=new W(17*this.D.length);t.append("("),t.append(this.D[0]);for(let s=1;s<this.D.length;s++)t.append(", "),t.append(this.D[s]);return t.append(")"),t.toString()}return"()"}getY(t){return this.D[t].y}toCoordinateArray(){return this.D}getM(t){return this.hasM()?this.D[t].getM():h.NaN}setOrdinate(t,s,i){switch(s){case V.X:this.D[t].x=i;break;case V.Y:this.D[t].y=i;break;default:this.D[t].setOrdinate(s,i)}}getZ(t){return this.hasZ()?this.D[t].getZ():h.NaN}size(){return this.D.length}getOrdinate(t,s){switch(s){case V.X:return this.D[t].x;case V.Y:return this.D[t].y;default:return this.D[t].getOrdinate(s)}}get interfaces_(){return[V,u]}}class Q{static instance(){return Q.instanceObject}readResolve(){return Q.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array)return new K(arguments[0]);if(s(arguments[0],V))return new K(arguments[0])}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new K(arguments[0],t)}if(3===arguments.length){let t=arguments[2],s=arguments[1]-t;return t>1&&(t=1),s>3&&(s=3),s<2&&(s=2),new K(arguments[0],s+t,t)}}}get interfaces_(){return[H,u]}}Q.instanceObject=new Q;class J extends M{contains(){}}class $ extends J{}class tt extends ${constructor(t){super(),this.array=[],t instanceof M&&this.addAll(t)}contains(t){for(const s of this.array)if(0===s.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let s=0,i=this.array.length;s<i;s++)if(1===this.array[s].compareTo(t))return!!this.array.splice(s,0,t);return this.array.push(t),!0}addAll(t){for(const s of t)this.add(s);return!0}remove(){throw new E}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new st(this.array)}}let st=class{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new A;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new E}};class it{static sort(){const t=arguments[0];if(1===arguments.length)t.sort((t,s)=>t.compareTo(s));else if(2===arguments.length)t.sort((t,s)=>arguments[1].compare(t,s));else if(3===arguments.length){const s=t.slice(arguments[1],arguments[2]);s.sort();const i=t.slice(0,arguments[1]).concat(s,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of i)t.push(e)}else if(4===arguments.length){const s=t.slice(arguments[1],arguments[2]);s.sort((t,s)=>arguments[3].compare(t,s));const i=t.slice(0,arguments[1]).concat(s,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of i)t.push(e)}}static asList(t){const s=new C;for(const i of t)s.add(i);return s}static copyOf(t,s){return t.slice(0,s)}}class et extends G{constructor(){super(),et.constructor_.apply(this,arguments)}static constructor_(){if(this.R=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],s=arguments[1];if(G.constructor_.call(this,s),null===t&&(t=[]),G.hasNullElements(t))throw new n("geometries must not contain null elements");this.R=t}}computeEnvelopeInternal(){const t=new O;for(let s=0;s<this.R.length;s++)t.expandToInclude(this.R[s].getEnvelopeInternal());return t}getGeometryN(t){return this.R[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let s=-1;for(let i=0;i<this.R.length;i++){const e=this.R[i].getCoordinates();for(let i=0;i<e.length;i++)s++,t[s]=e[i]}return t}getArea(){let t=0;for(let s=0;s<this.R.length;s++)t+=this.R[s].getArea();return t}copyInternal(){const t=new Array(this.R.length).fill(null);for(let s=0;s<t.length;s++)t[s]=this.R[s].copy();return new et(t,this.p)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];if(!this.isEquivalentClass(t))return!1;const i=t;if(this.R.length!==i.R.length)return!1;for(let e=0;e<this.R.length;e++)if(!this.R[e].equalsExact(i.R[e],s))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this.R.length,s=new C(t);for(let i=0;i<t;i++)s.add(this.R[i].reverse());return this.getFactory().buildGeometry(s)}getTypeCode(){return G.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=B.FALSE;for(let s=0;s<this.R.length;s++)t=Math.max(t,this.R[s].getDimension());return t}getNumGeometries(){return this.R.length}getBoundary(){return G.checkNotGeometryCollection(this),a.shouldNeverReachHere(),null}getGeometryType(){return G.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this.R.length;t++)if(!this.R[t].isEmpty())return!1;return!0}normalize(){for(let t=0;t<this.R.length;t++)this.R[t].normalize();it.sort(this.R)}getCoordinate(){return this.isEmpty()?null:this.R[0].getCoordinate()}getBoundaryDimension(){let t=B.FALSE;for(let s=0;s<this.R.length;s++)t=Math.max(t,this.R[s].getBoundaryDimension());return t}getLength(){let t=0;for(let s=0;s<this.R.length;s++)t+=this.R[s].getLength();return t}getNumPoints(){let t=0;for(let s=0;s<this.R.length;s++)t+=this.R[s].getNumPoints();return t}compareToSameClass(){if(1===arguments.length){const t=arguments[0],s=new tt(it.asList(this.R)),i=new tt(it.asList(t.R));return this.compare(s,i)}if(2===arguments.length){const t=arguments[1],s=arguments[0],i=this.getNumGeometries(),e=s.getNumGeometries();let n=0;for(;n<i&&n<e;){const i=this.getGeometryN(n),e=s.getGeometryN(n),r=i.compareToSameClass(e,t);if(0!==r)return r;n++}return n<i?1:n<e?-1:0}}apply(){if(s(arguments[0],F)){const t=arguments[0];for(let s=0;s<this.R.length;s++)this.R[s].apply(t)}else if(s(arguments[0],X)){const t=arguments[0];if(0===this.R.length)return null;for(let s=0;s<this.R.length&&(this.R[s].apply(t),!t.isDone());s++);t.isGeometryChanged()&&this.geometryChanged()}else if(s(arguments[0],j)){const t=arguments[0];t.filter(this);for(let s=0;s<this.R.length;s++)this.R[s].apply(t)}else if(s(arguments[0],I)){const t=arguments[0];t.filter(this);for(let s=0;s<this.R.length;s++)this.R[s].apply(t)}}}class nt{}class rt extends et{constructor(){super(),rt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];et.constructor_.call(this,t,s)}copyInternal(){const t=new Array(this.R.length).fill(null);for(let s=0;s<t.length;s++)t[s]=this.R[s].copy();return new rt(t,this.p)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,s)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return G.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new C;for(let i=0;i<this.R.length;i++){const s=this.R[i].getBoundary();for(let i=0;i<s.getNumGeometries();i++)t.add(s.getGeometryN(i))}const s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))}getGeometryType(){return G.TYPENAME_MULTIPOLYGON}get interfaces_(){return[nt]}}let ht=class{get(){}put(){}size(){}values(){}entrySet(){}};class ot extends J{constructor(t){super(),this.map=new Map,t instanceof M&&this.addAll(t)}contains(t){const s=t.hashCode?t.hashCode():t;return!!this.map.has(s)}add(t){const s=t.hashCode?t.hashCode():t;return!this.map.has(s)&&!!this.map.set(s,t)}addAll(t){for(const s of t)this.add(s);return!0}remove(){throw new E}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new ut(this.map)}[Symbol.iterator](){return this.map}}let ut=class{constructor(t){this.iterator=t.values();const{done:s,value:i}=this.iterator.next();this.done=s,this.value=i}next(){if(this.done)throw new A;const t=this.value,{done:s,value:i}=this.iterator.next();return this.done=s,this.value=i,t}hasNext(){return!this.done}remove(){throw new E}};class lt extends ht{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,s){return this.map.set(t,s),s}values(){const t=new C,s=this.map.values();let i=s.next();for(;!i.done;)t.add(i.value),i=s.next();return t}entrySet(){const t=new ot;return this.map.entries().forEach(s=>t.add(s)),t}size(){return this.map.size()}}class ct{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,s){return t<s?-1:t>s?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new ct(t)}}class at{constructor(){at.constructor_.apply(this,arguments)}static constructor_(){if(this.T=null,this.O=null,0===arguments.length)this.T=at.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ft){const t=arguments[0];this.T=t,t===at.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this.T=at.FIXED,this.setScale(t)}else if(arguments[0]instanceof at){const t=arguments[0];this.T=t.T,this.O=t.O}}static mostPrecise(t,s){return t.compareTo(s)>=0?t:s}equals(t){if(!(t instanceof at))return!1;const s=t;return this.T===s.T&&this.O===s.O}compareTo(t){const s=t,i=this.getMaximumSignificantDigits(),e=s.getMaximumSignificantDigits();return ct.compare(i,e)}getType(){return this.T}toString(){let t="UNKNOWN";return this.T===at.FLOATING?t="Floating":this.T===at.FLOATING_SINGLE?t="Floating-Single":this.T===at.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];return h.isNaN(t)||this.T===at.FLOATING_SINGLE?t:this.T===at.FIXED?Math.round(t*this.O)/this.O:t}if(arguments[0]instanceof m){const t=arguments[0];if(this.T===at.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this.T===at.FLOATING?t=16:this.T===at.FLOATING_SINGLE?t=6:this.T===at.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this.O=Math.abs(t)}getScale(){return this.O}isFloating(){return this.T===at.FLOATING||this.T===at.FLOATING_SINGLE}get interfaces_(){return[u,o]}}class ft{constructor(){ft.constructor_.apply(this,arguments)}static constructor_(){this.k=null;const t=arguments[0];this.k=t,ft.nameToTypeMap.put(t,this)}readResolve(){return ft.nameToTypeMap.get(this.k)}toString(){return this.k}get interfaces_(){return[u]}}ft.nameToTypeMap=new lt,at.Type=ft,at.FIXED=new ft("FIXED"),at.FLOATING=new ft("FLOATING"),at.FLOATING_SINGLE=new ft("FLOATING SINGLE"),at.maximumPreciseValue=9007199254740992;class dt extends et{constructor(){super(),dt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];et.constructor_.call(this,t,s)}copyInternal(){const t=new Array(this.R.length).fill(null);for(let s=0;s<t.length;s++)t[s]=this.R[s].copy();return new dt(t,this.p)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,s)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?B.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this.R.length;t++)if(!this.R[t].isClosed())return!1;return!0}getTypeCode(){return G.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new E}getGeometryType(){return G.TYPENAME_MULTILINESTRING}get interfaces_(){return[z]}}class gt{}class wt extends e{constructor(t){super(t),this.name=Object.keys({IllegalStateException:wt})[0]}}class pt extends G{constructor(){super(),pt.constructor_.apply(this,arguments)}static constructor_(){this.D=null;const t=arguments[0],s=arguments[1];G.constructor_.call(this,s),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this.D.getX(0),this.D.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new pt(this.D.copy(),this.p)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),s))}return super.equalsExact.apply(this,arguments)}reverseInternal(){return this.getFactory().createPoint(this.D.copy())}getTypeCode(){return G.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new wt("getX called on empty Point");return this.getCoordinate().x}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return G.TYPENAME_POINT}getCoordinateSequence(){return this.D}getY(){if(null===this.getCoordinate())throw new wt("getY called on empty Point");return this.getCoordinate().y}isSimple(){return!0}normalize(){}getCoordinate(){return 0!==this.D.size()?this.D.getCoordinate(0):null}getBoundaryDimension(){return B.FALSE}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this.D,t.D)}}apply(){if(s(arguments[0],F)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(s(arguments[0],X)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.D,0),t.isGeometryChanged()&&this.geometryChanged()}else(s(arguments[0],j)||s(arguments[0],I))&&arguments[0].filter(this)}isEmpty(){return 0===this.D.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),a.isTrue(t.size()<=1),this.D=t}get interfaces_(){return[gt]}}class mt{static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let s=0;const i=t[0].x;for(let e=1;e<t.length-1;e++){const n=t[e].x-i,r=t[e+1].y;s+=n*(t[e-1].y-r)}return s/2}if(s(arguments[0],V)){const t=arguments[0],s=t.size();if(s<3)return 0;const i=new m,e=new m,n=new m;t.getCoordinate(0,e),t.getCoordinate(1,n);const r=e.x;n.x-=r;let h=0;for(let o=1;o<s-1;o++)i.y=e.y,e.x=n.x,e.y=n.y,t.getCoordinate(o+1,n),n.x-=r,h+=e.x*(i.y-n.y);return h/2}}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(mt.ofRingSigned(t))}if(s(arguments[0],V)){const t=arguments[0];return Math.abs(mt.ofRingSigned(t))}}}class yt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,s){this.str=this.str.substr(0,t)+s+this.str.substr(t+1)}toString(){return this.str}}class bt{constructor(){bt.constructor_.apply(this,arguments)}static constructor_(){if(this.q=0,this.B=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof bt){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];bt.constructor_.call(this,bt.parse(t))}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.init(t,s)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];return bt.determinant(bt.valueOf(t),bt.valueOf(s),bt.valueOf(i),bt.valueOf(e))}if(arguments[3]instanceof bt&&arguments[2]instanceof bt&&arguments[0]instanceof bt&&arguments[1]instanceof bt){const t=arguments[1],s=arguments[2],i=arguments[3];return arguments[0].multiply(i).selfSubtract(t.multiply(s))}}static sqr(t){return bt.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return bt.parse(t)}if("number"==typeof arguments[0])return new bt(arguments[0])}static sqrt(t){return bt.valueOf(t).sqrt()}static parse(t){let s=0;const i=t.length;for(;q.isWhitespace(t.charAt(s));)s++;let e=!1;if(s<i){const i=t.charAt(s);"-"!==i&&"+"!==i||(s++,"-"===i&&(e=!0))}const n=new bt;let r=0,h=0,o=0,u=!1;for(;!(s>=i);){const i=t.charAt(s);if(s++,q.isDigit(i)){const t=i-"0";n.selfMultiply(bt.TEN),n.selfAdd(t),r++;continue}if("."!==i){if("e"===i||"E"===i){const i=t.substring(s);try{o=ct.parseInt(i)}catch(a){throw a instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+i+" in string "+t):a}break}throw new NumberFormatException("Unexpected character '"+i+"' at position "+s+" in string "+t)}h=r,u=!0}let l=n;u||(h=r);const c=r-h-o;if(0===c)l=n;else if(c>0){const t=bt.TEN.pow(c);l=n.divide(t)}else if(c<0){const t=bt.TEN.pow(-c);l=n.multiply(t)}return e?l.negate():l}static createNaN(){return new bt(h.NaN,h.NaN)}static copy(t){return new bt(t)}static magnitude(t){const s=Math.abs(t),i=Math.log(s)/Math.log(10);let e=Math.trunc(Math.floor(i));return 10*Math.pow(10,e)<=s&&(e+=1),e}static stringOfChar(t,s){const i=new yt;for(let e=0;e<s;e++)i.append(t);return i.toString()}le(t){return this.q<t.q||this.q===t.q&&this.B<=t.B}extractSignificantDigits(t,s){let i=this.abs(),e=bt.magnitude(i.q);const n=bt.TEN.pow(e);i=i.divide(n),i.gt(bt.TEN)?(i=i.divide(bt.TEN),e+=1):i.lt(bt.ONE)&&(i=i.multiply(bt.TEN),e-=1);const r=e+1,h=new yt,o=bt.MAX_PRINT_DIGITS-1;for(let u=0;u<=o;u++){t&&u===r&&h.append(".");const s=Math.trunc(i.q);if(s<0)break;let e=!1,n=0;s>9?(e=!0,n="9"):n="0"+s,h.append(n),i=i.subtract(bt.valueOf(s)).multiply(bt.TEN),e&&i.selfAdd(bt.TEN);let l=!0;const c=bt.magnitude(i.q);if(c<0&&Math.abs(c)>=o-u&&(l=!1),!l)break}return s[0]=e,h.toString()}sqr(){return this.multiply(this)}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}setValue(){if(arguments[0]instanceof bt){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}multiply(){if(arguments[0]instanceof bt){const t=arguments[0];return t.isNaN()?bt.createNaN():bt.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return h.isNaN(t)?bt.createNaN():bt.copy(this).selfMultiply(t,0)}}isNaN(){return h.isNaN(this.q)}reciprocal(){let t=null,s=null,i=null,e=null,n=null,r=null,h=null,o=null;n=1/this.q,r=bt.SPLIT*n,t=r-n,o=bt.SPLIT*this.q,t=r-t,s=n-t,i=o-this.q,h=n*this.q,i=o-i,e=this.q-i,o=t*i-h+t*e+s*i+s*e,r=(1-h-o-n*this.B)/this.q;const u=n+r;return new bt(u,n-u+r)}doubleValue(){return this.q+this.B}subtract(){if(arguments[0]instanceof bt){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof bt){const t=arguments[0];return this.q===t.q&&this.B===t.B}}isZero(){return 0===this.q&&0===this.B}selfSubtract(){if(arguments[0]instanceof bt){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.q,-t.B)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof bt){const t=arguments[0];return this.selfDivide(t.q,t.B)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];let i=null,e=null,n=null,r=null,h=null,o=null,u=null,l=null;return h=this.q/t,o=bt.SPLIT*h,i=o-h,l=bt.SPLIT*t,i=o-i,e=h-i,n=l-t,u=h*t,n=l-n,r=t-n,l=i*n-u+i*r+e*n+e*r,o=(this.q-u-l+this.B-h*s)/t,l=h+o,this.q=l,this.B=h-l+o,this}}dump(){return"DD<"+this.q+", "+this.B+">"}divide(){if(arguments[0]instanceof bt){const t=arguments[0];let s=null,i=null,e=null,n=null,r=null,h=null,o=null,u=null;return r=this.q/t.q,h=bt.SPLIT*r,s=h-r,u=bt.SPLIT*t.q,s=h-s,i=r-s,e=u-t.q,o=r*t.q,e=u-e,n=t.q-e,u=s*e-o+s*n+i*e+i*n,h=(this.q-o-u+this.B-r*t.B)/t.q,u=r+h,new bt(u,r-u+h)}if("number"==typeof arguments[0]){const t=arguments[0];return h.isNaN(t)?bt.createNaN():bt.copy(this).selfDivide(t,0)}}ge(t){return this.q>t.q||this.q===t.q&&this.B>=t.B}pow(t){if(0===t)return bt.valueOf(1);let s=new bt(this),i=bt.valueOf(1),e=Math.abs(t);if(e>1)for(;e>0;)e%2==1&&i.selfMultiply(s),e/=2,e>0&&(s=s.sqr());else i=s;return t<0?i.reciprocal():i}ceil(){if(this.isNaN())return bt.NaN;const t=Math.ceil(this.q);let s=0;return t===this.q&&(s=Math.ceil(this.B)),new bt(t,s)}compareTo(t){const s=t;return this.q<s.q?-1:this.q>s.q?1:this.B<s.B?-1:this.B>s.B?1:0}rint(){return this.isNaN()?this:this.add(.5).floor()}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return bt.valueOf(0);if(this.isNegative())return bt.NaN;const t=1/Math.sqrt(this.q),s=this.q*t,i=bt.valueOf(s),e=this.subtract(i.sqr()).q*(.5*t);return i.add(e)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof bt){const t=arguments[0];return this.selfAdd(t.q,t.B)}if("number"==typeof arguments[0]){const t=arguments[0];let s=null,i=null,e=null,n=null,r=null,h=null;return e=this.q+t,r=e-this.q,n=e-r,n=t-r+(this.q-n),h=n+this.B,s=e+h,i=h+(e-s),this.q=s+i,this.B=i+(s-this.q),this}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];let i=null,e=null,n=null,r=null,h=null,o=null,u=null,l=null;h=this.q+t,n=this.B+s,u=h-this.q,l=n-this.B,o=h-u,r=n-l,o=t-u+(this.q-o),r=s-l+(this.B-r),u=o+n,i=h+u,e=u+(h-i),u=r+e;const c=i+u,a=u+(i-c);return this.q=c,this.B=a,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof bt){const t=arguments[0];return this.selfMultiply(t.q,t.B)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];let i=null,e=null,n=null,r=null,h=null,o=null;h=bt.SPLIT*this.q,i=h-this.q,o=bt.SPLIT*t,i=h-i,e=this.q-i,n=o-t,h=this.q*t,n=o-n,r=t-n,o=i*n-h+i*r+e*n+e*r+(this.q*s+this.B*t);const u=h+o;i=h-u;const l=o+i;return this.q=u,this.B=l,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return bt.NaN;const t=Math.floor(this.q);let s=0;return t===this.q&&(s=Math.floor(this.B)),new bt(t,s)}negate(){return this.isNaN()?this:new bt(-this.q,-this.B)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}intValue(){return Math.trunc(this.q)}toString(){const t=bt.magnitude(this.q);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const s=new Array(1).fill(null),i=this.extractSignificantDigits(!0,s),e=s[0]+1;let n=i;if("."===i.charAt(0))n="0"+i;else if(e<0)n="0."+bt.stringOfChar("0",-e)+i;else if(-1===i.indexOf(".")){const t=e-i.length;n=i+bt.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+n:n}toSciNotation(){if(this.isZero())return bt.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const s=new Array(1).fill(null),i=this.extractSignificantDigits(!1,s),e=bt.SCI_NOT_EXPONENT_CHAR+s[0];if("0"===i.charAt(0))throw new wt("Found leading zero: "+i);let n="";i.length>1&&(n=i.substring(1));const r=i.charAt(0)+"."+n;return this.isNegative()?"-"+r+e:r+e}abs(){return this.isNaN()?bt.NaN:this.isNegative()?this.negate():new bt(this)}isPositive(){return this.q>0||0===this.q&&this.B>0}lt(t){return this.q<t.q||this.q===t.q&&this.B<t.B}add(){if(arguments[0]instanceof bt){const t=arguments[0];return bt.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return bt.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.q=t,this.B=0}else if(arguments[0]instanceof bt){const t=arguments[0];this.q=t.q,this.B=t.B}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.q=t,this.B=s}}gt(t){return this.q>t.q||this.q===t.q&&this.B>t.B}isNegative(){return this.q<0||0===this.q&&this.B<0}trunc(){return this.isNaN()?bt.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this.q>0?1:this.q<0?-1:this.B>0?1:this.B<0?-1:0}get interfaces_(){return[u,o,f]}}bt.PI=new bt(3.141592653589793,12246467991473532e-32),bt.TWO_PI=new bt(6.283185307179586,24492935982947064e-32),bt.PI_2=new bt(1.5707963267948966,6123233995736766e-32),bt.E=new bt(2.718281828459045,14456468917292502e-32),bt.NaN=new bt(h.NaN,h.NaN),bt.EPS=123259516440783e-46,bt.SPLIT=134217729,bt.MAX_PRINT_DIGITS=32,bt.TEN=bt.valueOf(10),bt.ONE=bt.valueOf(1),bt.SCI_NOT_EXPONENT_CHAR="E",bt.SCI_NOT_ZERO="0.0E0";class It{static orientationIndex(t,s,i){const e=It.orientationIndexFilter(t,s,i);if(e<=1)return e;const n=bt.valueOf(s.x).selfAdd(-t.x),r=bt.valueOf(s.y).selfAdd(-t.y),h=bt.valueOf(i.x).selfAdd(-s.x),o=bt.valueOf(i.y).selfAdd(-s.y);return n.selfMultiply(o).selfSubtract(r.selfMultiply(h)).signum()}static signOfDet2x2(){if(arguments[3]instanceof bt&&arguments[2]instanceof bt&&arguments[0]instanceof bt&&arguments[1]instanceof bt){const t=arguments[1],s=arguments[2],i=arguments[3];return arguments[0].multiply(i).selfSubtract(t.multiply(s)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3],n=bt.valueOf(t),r=bt.valueOf(s),h=bt.valueOf(i),o=bt.valueOf(e);return n.multiply(o).selfSubtract(r.multiply(h)).signum()}}static intersection(t,s,i,e){const n=new bt(t.y).selfSubtract(s.y),r=new bt(s.x).selfSubtract(t.x),o=new bt(t.x).selfMultiply(s.y).selfSubtract(new bt(s.x).selfMultiply(t.y)),u=new bt(i.y).selfSubtract(e.y),l=new bt(e.x).selfSubtract(i.x),c=new bt(i.x).selfMultiply(e.y).selfSubtract(new bt(e.x).selfMultiply(i.y)),a=r.multiply(c).selfSubtract(l.multiply(o)),f=u.multiply(o).selfSubtract(n.multiply(c)),d=n.multiply(l).selfSubtract(u.multiply(r)),g=a.selfDivide(d).doubleValue(),w=f.selfDivide(d).doubleValue();return h.isNaN(g)||h.isInfinite(g)||h.isNaN(w)||h.isInfinite(w)?null:new m(g,w)}static orientationIndexFilter(t,s,i){let e=null;const n=(t.x-i.x)*(s.y-i.y),r=(t.y-i.y)*(s.x-i.x),h=n-r;if(n>0){if(r<=0)return It.signum(h);e=n+r}else{if(!(n<0))return It.signum(h);if(r>=0)return It.signum(h);e=-n-r}const o=It.DP_SAFE_EPSILON*e;return h>=o||-h>=o?It.signum(h):2}static signum(t){return t>0?1:t<0?-1:0}}It.DP_SAFE_EPSILON=1e-15;class Et{static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],s=t.length-1;if(s<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let i=t[0],e=0;for(let n=1;n<=s;n++){const s=t[n];s.y>i.y&&(i=s,e=n)}let r=e;do{r-=1,r<0&&(r=s)}while(t[r].equals2D(i)&&r!==e);let h=e;do{h=(h+1)%s}while(t[h].equals2D(i)&&h!==e);const o=t[r],u=t[h];if(o.equals2D(i)||u.equals2D(i)||o.equals2D(u))return!1;const l=Et.index(o,i,u);let c=null;return c=0===l?o.x>u.x:l>0,c}if(s(arguments[0],V)){const t=arguments[0],s=t.size()-1;if(s<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let i=t.getCoordinate(0),e=0;for(let n=1;n<=s;n++){const s=t.getCoordinate(n);s.y>i.y&&(i=s,e=n)}let r=null,h=e;do{h-=1,h<0&&(h=s),r=t.getCoordinate(h)}while(r.equals2D(i)&&h!==e);let o=null,u=e;do{u=(u+1)%s,o=t.getCoordinate(u)}while(o.equals2D(i)&&u!==e);if(r.equals2D(i)||o.equals2D(i)||r.equals2D(o))return!1;const l=Et.index(r,i,o);let c=null;return c=0===l?r.x>o.x:l>0,c}}static index(t,s,i){return It.orientationIndex(t,s,i)}}Et.CLOCKWISE=-1,Et.RIGHT=Et.CLOCKWISE,Et.COUNTERCLOCKWISE=1,Et.LEFT=Et.COUNTERCLOCKWISE,Et.COLLINEAR=0,Et.STRAIGHT=Et.COLLINEAR;class Mt extends G{constructor(){super(),Mt.constructor_.apply(this,arguments)}static constructor_(){this.G=null,this.F=null;let t=arguments[0],s=arguments[1],i=arguments[2];if(G.constructor_.call(this,i),null===t&&(t=this.getFactory().createLinearRing()),null===s&&(s=[]),G.hasNullElements(s))throw new n("holes must not contain null elements");if(t.isEmpty()&&G.hasNonEmptyElements(s))throw new n("shell is empty but holes are not");this.G=t,this.F=s}computeEnvelopeInternal(){return this.G.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let s=-1;const i=this.G.getCoordinates();for(let e=0;e<i.length;e++)s++,t[s]=i[e];for(let e=0;e<this.F.length;e++){const i=this.F[e].getCoordinates();for(let e=0;e<i.length;e++)s++,t[s]=i[e]}return t}getArea(){let t=0;t+=mt.ofRing(this.G.getCoordinateSequence());for(let s=0;s<this.F.length;s++)t-=mt.ofRing(this.F[s].getCoordinateSequence());return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];if(!this.isEquivalentClass(t))return!1;const i=t,e=this.G,n=i.G;if(!e.equalsExact(n,s))return!1;if(this.F.length!==i.F.length)return!1;for(let r=0;r<this.F.length;r++)if(!this.F[r].equalsExact(i.F[r],s))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this.getExteriorRing().reverse(),s=new Array(this.getNumInteriorRing()).fill(null);for(let i=0;i<s.length;i++)s[i]=this.getInteriorRingN(i).reverse();return this.getFactory().createPolygon(t,s)}getTypeCode(){return G.TYPECODE_POLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this.F.length+1).fill(null);t[0]=this.G;for(let s=0;s<this.F.length;s++)t[s+1]=this.F[s];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return G.TYPENAME_POLYGON}getExteriorRing(){return this.G}copyInternal(){const t=this.G.copy(),s=new Array(this.F.length).fill(null);for(let i=0;i<this.F.length;i++)s[i]=this.F[i].copy();return new Mt(t,s,this.p)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this.G)return!1;if(5!==this.G.getNumPoints())return!1;const t=this.G.getCoordinateSequence(),s=this.getEnvelopeInternal();for(let n=0;n<5;n++){const i=t.getX(n);if(i!==s.getMinX()&&i!==s.getMaxX())return!1;const e=t.getY(n);if(e!==s.getMinY()&&e!==s.getMaxY())return!1}let i=t.getX(0),e=t.getY(0);for(let n=1;n<=4;n++){const s=t.getX(n),r=t.getY(n);if(s!==i==(r!==e))return!1;i=s,e=r}return!0}normalize(){if(0===arguments.length){this.G=this.normalized(this.G,!0);for(let t=0;t<this.F.length;t++)this.F[t]=this.normalized(this.F[t],!1);it.sort(this.F)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];if(t.isEmpty())return null;const i=t.getCoordinateSequence(),e=Y.minCoordinateIndex(i,0,i.size()-2);Y.scroll(i,e,!0),Et.isCCW(i)===s&&Y.reverse(i)}}getCoordinate(){return this.G.getCoordinate()}getNumInteriorRing(){return this.F.length}getBoundaryDimension(){return 1}getLength(){let t=0;t+=this.G.getLength();for(let s=0;s<this.F.length;s++)t+=this.F[s].getLength();return t}getNumPoints(){let t=this.G.getNumPoints();for(let s=0;s<this.F.length;s++)t+=this.F[s].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,s){const i=t.copy();return this.normalize(i,s),i}compareToSameClass(){if(1===arguments.length){const t=arguments[0],s=this.G,i=t.G;return s.compareToSameClass(i)}if(2===arguments.length){const t=arguments[1],s=arguments[0],i=this.G,e=s.G,n=i.compareToSameClass(e,t);if(0!==n)return n;const r=this.getNumInteriorRing(),h=s.getNumInteriorRing();let o=0;for(;o<r&&o<h;){const i=this.getInteriorRingN(o),e=s.getInteriorRingN(o),n=i.compareToSameClass(e,t);if(0!==n)return n;o++}return o<r?1:o<h?-1:0}}apply(){if(s(arguments[0],F)){const t=arguments[0];this.G.apply(t);for(let s=0;s<this.F.length;s++)this.F[s].apply(t)}else if(s(arguments[0],X)){const t=arguments[0];if(this.G.apply(t),!t.isDone())for(let s=0;s<this.F.length&&(this.F[s].apply(t),!t.isDone());s++);t.isGeometryChanged()&&this.geometryChanged()}else if(s(arguments[0],j))arguments[0].filter(this);else if(s(arguments[0],I)){const t=arguments[0];t.filter(this),this.G.apply(t);for(let s=0;s<this.F.length;s++)this.F[s].apply(t)}}isEmpty(){return this.G.isEmpty()}getInteriorRingN(t){return this.F[t]}get interfaces_(){return[nt]}}class Nt extends et{constructor(){super(),Nt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];et.constructor_.call(this,t,s)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof G){const t=arguments[0],s=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,s)}return super.equalsExact.apply(this,arguments)}getTypeCode(){return G.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return G.TYPENAME_MULTIPOINT}copyInternal(){const t=new Array(this.R.length).fill(null);for(let s=0;s<t.length;s++)t[s]=this.R[s].copy();return new Nt(t,this.p)}isValid(){return!0}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this.R[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return B.FALSE}get interfaces_(){return[gt]}}class xt{constructor(){xt.constructor_.apply(this,arguments)}static constructor_(){if(this.V=null,this.j=null,this.C=null,0===arguments.length)xt.constructor_.call(this,new at,0);else if(1===arguments.length){if(s(arguments[0],H)){const t=arguments[0];xt.constructor_.call(this,new at,0,t)}else if(arguments[0]instanceof at){const t=arguments[0];xt.constructor_.call(this,t,0,xt.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];xt.constructor_.call(this,t,s,xt.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.V=t,this.j=i,this.C=s}}static toMultiPolygonArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toGeometryArray(t){if(null===t)return null;const s=new Array(t.size()).fill(null);return t.toArray(s)}static getDefaultCoordinateSequenceFactory(){return Q.instance()}static toMultiLineStringArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toLineStringArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toMultiPointArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toLinearRingArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toPointArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static toPolygonArray(t){const s=new Array(t.size()).fill(null);return t.toArray(s)}static createPointFromInternalCoord(t,s){return s.getPrecisionModel().makePrecise(t),s.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new n("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(s(arguments[0],V))return new U(arguments[0],this)}}createMultiLineString(){return 0===arguments.length?new dt(null,this):1===arguments.length?new dt(arguments[0],this):void 0}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(s(arguments[0],V)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Z){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length)return new Mt(arguments[0],arguments[1],this)}getSRID(){return this.C}createGeometryCollection(){return 0===arguments.length?new et(null,this):1===arguments.length?new et(arguments[0],this):void 0}getPrecisionModel(){return this.V}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(s(arguments[0],V))return new Z(arguments[0],this)}}createMultiPolygon(){return 0===arguments.length?new rt(null,this):1===arguments.length?new rt(arguments[0],this):void 0}createMultiPoint(){if(0===arguments.length)return new Nt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new Nt(arguments[0],this);if(s(arguments[0],V)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const s=new Array(t.size()).fill(null);for(let i=0;i<t.size();i++){const e=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());Y.copy(t,i,e,0,1),s[i]=this.createPoint(e)}return this.createMultiPoint(s)}}}buildGeometry(t){let s=null,i=!1,e=!1;for(let r=t.iterator();r.hasNext();){const t=r.next(),n=t.getTypeCode();null===s&&(s=n),n!==s&&(i=!0),t instanceof et&&(e=!0)}if(null===s)return this.createGeometryCollection();if(i||e)return this.createGeometryCollection(xt.toGeometryArray(t));const n=t.iterator().next();if(t.size()>1){if(n instanceof Mt)return this.createMultiPolygon(xt.toPolygonArray(t));if(n instanceof U)return this.createMultiLineString(xt.toLineStringArray(t));if(n instanceof pt)return this.createMultiPoint(xt.toPointArray(t));a.shouldNeverReachHere("Unhandled geometry type: "+n.getGeometryType())}return n}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(s(arguments[0],V))return new pt(arguments[0],this)}}getCoordinateSequenceFactory(){return this.j}get interfaces_(){return[u]}}const At="XY",Ct={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},St="EMPTY";for(const Ii in Ct)Ct[Ii].toUpperCase();class _t{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,s){return t>="0"&&t<="9"||"."==t&&!(void 0!==s&&s)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),s=this.index_;let i,e=t;if("("==t)i=2;else if(","==t)i=5;else if(")"==t)i=3;else if(this.isNumeric_(t)||"-"==t)i=4,e=this.readNumber_();else if(this.isAlpha_(t))i=1,e=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);i=6}return{position:s,value:e,type:i}}readNumber_(){let t;const s=this.index_;let i=!1,e=!1;do{"."==t?i=!0:"e"!=t&&"E"!=t||(e=!0),t=this.nextChar_()}while(this.isNumeric_(t,i)||!e&&("e"==t||"E"==t)||e&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(s,this.index_--))}readText_(){let t;const s=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(s,this.index_--).toUpperCase()}}class Lt{constructor(t,s){this.lexer_=t,this.token_,this.layout_=At,this.factory=s}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const s=this.isTokenType(t);return s&&this.consume_(),s}parse(){return this.consume_(),this.parseGeometry_()}parseGeometryLayout_(){let t=At;const s=this.token_;if(this.isTokenType(1)){const i=s.value;"Z"===i?t="XYZ":"M"===i?t="XYM":"ZM"===i&&(t="XYZM"),t!==At&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(2)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(5));if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(2)){const t=this.parsePoint_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(2)){const t=this.parsePointList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(2)){const t=this.parseLineStringTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(2)){let t;if(t=2==this.token_.type?this.parsePointTextList_():this.parsePointList_(),this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(2)){const t=this.parseLineStringTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(2)){const t=this.parsePolygonTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],s=this.layout_.length;for(let i=0;i<s;++i){const s=this.token_;if(!this.match(4))break;t.push(s.value)}if(t.length==s)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(5);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(5);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(5);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(5);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(1)&&this.token_.value==St;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,s=t=>t?new m(...t):new m,i=i=>{const e=i.map(i=>t.createLinearRing(i.map(s)));return e.length>1?t.createPolygon(e[0],e.slice(1)):1===e.length?t.createPolygon(e[0]):t.createPolygon()},e=this.token_;if(this.match(1)){const n=e.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==n){const s=this.parseGeometryCollectionText_();return t.createGeometryCollection(s)}switch(n){case"POINT":{const s=this.parsePointText_();return s?t.createPoint(new m(...s)):t.createPoint()}case"LINESTRING":{const i=this.parseLineStringText_().map(s);return t.createLineString(i)}case"LINEARRING":{const i=this.parseLineStringText_().map(s);return t.createLinearRing(i)}case"POLYGON":{const s=this.parsePolygonText_();return s&&0!==s.length?i(s):t.createPolygon()}case"MULTIPOINT":{const i=this.parseMultiPointText_();if(!i||0===i.length)return t.createMultiPoint();const e=i.map(s).map(s=>t.createPoint(s));return t.createMultiPoint(e)}case"MULTILINESTRING":{const i=this.parseMultiLineStringText_().map(i=>t.createLineString(i.map(s)));return t.createMultiLineString(i)}case"MULTIPOLYGON":{const s=this.parseMultiPolygonText_();if(!s||0===s.length)return t.createMultiPolygon();const e=s.map(i);return t.createMultiPolygon(e)}default:throw new Error("Invalid geometry type: "+n)}}throw new Error(this.formatErrorMessage_())}}function vt(t){if(t.isEmpty())return"";const s=t.getCoordinate(),i=[s.x,s.y];return void 0===s.z||Number.isNaN(s.z)||i.push(s.z),void 0===s.m||Number.isNaN(s.m)||i.push(s.m),i.join(" ")}function Pt(t){const s=t.getCoordinates().map(t=>{const s=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||s.push(t.z),void 0===t.m||Number.isNaN(t.m)||s.push(t.m),s}),i=[];for(let e=0,n=s.length;e<n;++e)i.push(s[e].join(" "));return i.join(", ")}function Dt(t){const s=[];s.push("("+Pt(t.getExteriorRing())+")");for(let i=0,e=t.getNumInteriorRing();i<e;++i)s.push("("+Pt(t.getInteriorRingN(i))+")");return s.join(", ")}const Rt={Point:vt,LineString:Pt,LinearRing:Pt,Polygon:Dt,MultiPoint:function(t){const s=[];for(let i=0,e=t.getNumGeometries();i<e;++i)s.push("("+vt(t.getGeometryN(i))+")");return s.join(", ")},MultiLineString:function(t){const s=[];for(let i=0,e=t.getNumGeometries();i<e;++i)s.push("("+Pt(t.getGeometryN(i))+")");return s.join(", ")},MultiPolygon:function(t){const s=[];for(let i=0,e=t.getNumGeometries();i<e;++i)s.push("("+Dt(t.getGeometryN(i))+")");return s.join(", ")},GeometryCollection:function(t){const s=[];for(let i=0,e=t.getNumGeometries();i<e;++i)s.push(Tt(t.getGeometryN(i)));return s.join(", ")}};function Tt(t){let s=t.getGeometryType();const i=Rt[s];s=s.toUpperCase();const e=function(t){let s="";if(t.isEmpty())return s;const i=t.getCoordinate();return void 0===i.z||Number.isNaN(i.z)||(s+="Z"),void 0===i.m||Number.isNaN(i.m)||(s+="M"),s}(t);return e.length>0&&(s+=" "+e),t.isEmpty()?s+" "+St:s+" ("+i(t)+")"}class Ot{constructor(t){this.geometryFactory=t||new xt,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const s=new _t(t);return new Lt(s,this.geometryFactory).parse()}write(t){return Tt(t)}}class kt{constructor(t){this.parser=new Ot(t||new xt)}read(t){return this.parser.read(t)}}class qt{static toLocationSymbol(t){switch(t){case qt.EXTERIOR:return"e";case qt.BOUNDARY:return"b";case qt.INTERIOR:return"i";case qt.NONE:return"-"}throw new n("Unknown location value: "+t)}}qt.INTERIOR=0,qt.BOUNDARY=1,qt.EXTERIOR=2,qt.NONE=-1;class Bt{static opposite(t){return t===Bt.LEFT?Bt.RIGHT:t===Bt.RIGHT?Bt.LEFT:t}}Bt.ON=0,Bt.LEFT=1,Bt.RIGHT=2;class Gt{static intersection(t,s,i,e){const n=t.x<s.x?t.x:s.x,r=t.y<s.y?t.y:s.y,o=t.x>s.x?t.x:s.x,u=t.y>s.y?t.y:s.y,l=i.x<e.x?i.x:e.x,c=i.y<e.y?i.y:e.y,a=i.x>e.x?i.x:e.x,f=i.y>e.y?i.y:e.y,d=((n>l?n:l)+(o<a?o:a))/2,g=((r>c?r:c)+(u<f?u:f))/2,w=t.x-d,p=t.y-g,y=s.x-d,b=s.y-g,I=i.x-d,E=i.y-g,M=e.x-d,N=e.y-g,x=p-b,A=y-w,C=w*b-y*p,S=E-N,_=M-I,L=I*N-M*E,v=x*_-S*A,P=(A*L-_*C)/v,D=(S*C-x*L)/v;return h.isNaN(P)||h.isInfinite(P)||h.isNaN(D)||h.isInfinite(D)?null:new m(P+d,D+g)}}class Ft{static pointToSegmentString(t,s){if(0===s.length)throw new n("Line array must contain at least one vertex");let i=t.distance(s[0]);for(let e=0;e<s.length-1;e++){const n=Ft.pointToSegment(t,s[e],s[e+1]);n<i&&(i=n)}return i}static segmentToSegment(t,s,i,e){if(t.equals(s))return Ft.pointToSegment(t,i,e);if(i.equals(e))return Ft.pointToSegment(e,t,s);let n=!1;if(O.intersects(t,s,i,e)){const r=(s.x-t.x)*(e.y-i.y)-(s.y-t.y)*(e.x-i.x);if(0===r)n=!0;else{const h=(t.y-i.y)*(e.x-i.x)-(t.x-i.x)*(e.y-i.y),o=((t.y-i.y)*(s.x-t.x)-(t.x-i.x)*(s.y-t.y))/r,u=h/r;(u<0||u>1||o<0||o>1)&&(n=!0)}}else n=!0;return n?R.min(Ft.pointToSegment(t,i,e),Ft.pointToSegment(s,i,e),Ft.pointToSegment(i,t,s),Ft.pointToSegment(e,t,s)):0}static pointToLinePerpendicular(t,s,i){const e=(i.x-s.x)*(i.x-s.x)+(i.y-s.y)*(i.y-s.y),n=((s.y-t.y)*(i.x-s.x)-(s.x-t.x)*(i.y-s.y))/e;return Math.abs(n)*Math.sqrt(e)}static pointToSegment(t,s,i){if(s.x===i.x&&s.y===i.y)return t.distance(s);const e=(i.x-s.x)*(i.x-s.x)+(i.y-s.y)*(i.y-s.y),n=((t.x-s.x)*(i.x-s.x)+(t.y-s.y)*(i.y-s.y))/e;if(n<=0)return t.distance(s);if(n>=1)return t.distance(i);const r=((s.y-t.y)*(i.x-s.x)-(s.x-t.x)*(i.y-s.y))/e;return Math.abs(r)*Math.sqrt(e)}}class zt{constructor(t){this.parser=new Ot(t)}write(t){return this.parser.write(t)}static toLineString(t,s){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+s.x+" "+s.y+" )"}}class Vt{constructor(){Vt.constructor_.apply(this,arguments)}static constructor_(){this.U=null,this.H=Array(2).fill().map(()=>Array(2)),this.W=new Array(2).fill(null),this.K=null,this.J=null,this.$=null,this.tt=null,this.V=null,this.W[0]=new m,this.W[1]=new m,this.$=this.W[0],this.tt=this.W[1],this.U=0}static nonRobustComputeEdgeDistance(t,s,i){const e=t.x-s.x,n=t.y-s.y,r=Math.sqrt(e*e+n*n);return a.isTrue(!(0===r&&!t.equals(s)),"Invalid distance calculation"),r}static computeEdgeDistance(t,s,i){const e=Math.abs(i.x-s.x),n=Math.abs(i.y-s.y);let r=-1;if(t.equals(s))r=0;else if(t.equals(i))r=e>n?e:n;else{const i=Math.abs(t.x-s.x),h=Math.abs(t.y-s.y);r=e>n?i:h,0!==r||t.equals(s)||(r=Math.max(i,h))}return a.isTrue(!(0===r&&!t.equals(s)),"Bad distance calculation"),r}computeIntersection(t,s,i,e){this.H[0][0]=t,this.H[0][1]=s,this.H[1][0]=i,this.H[1][1]=e,this.U=this.computeIntersect(t,s,i,e)}getIntersectionNum(){return this.U}computeIntLineIndex(){if(0===arguments.length)null===this.K&&(this.K=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this.K[t][0]=0,this.K[t][1]=1):(this.K[t][0]=1,this.K[t][1]=0)}}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let s=0;s<this.U;s++)if(!this.W[s].equals2D(this.H[t][0])&&!this.W[s].equals2D(this.H[t][1]))return!0;return!1}}getIntersection(t){return this.W[t]}getEdgeDistance(t,s){return Vt.computeEdgeDistance(this.W[s],this.H[t][0],this.H[t][1])}isCollinear(){return this.U===Vt.COLLINEAR_INTERSECTION}toString(){return zt.toLineString(this.H[0][0],this.H[0][1])+" - "+zt.toLineString(this.H[1][0],this.H[1][1])+this.getTopologySummary()}getEndpoint(t,s){return this.H[t][s]}getIndexAlongSegment(t,s){return this.computeIntLineIndex(),this.K[t][s]}getTopologySummary(){const t=new W;return this.isEndPoint()&&t.append(" endpoint"),this.J&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}isProper(){return this.hasIntersection()&&this.J}setPrecisionModel(t){this.V=t}isEndPoint(){return this.hasIntersection()&&!this.J}hasIntersection(){return this.U!==Vt.NO_INTERSECTION}isIntersection(t){for(let s=0;s<this.U;s++)if(this.W[s].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,s){return this.computeIntLineIndex(),this.W[this.K[t][s]]}}Vt.DONT_INTERSECT=0,Vt.DO_INTERSECT=1,Vt.COLLINEAR=2,Vt.NO_INTERSECTION=0,Vt.POINT_INTERSECTION=1,Vt.COLLINEAR_INTERSECTION=2;class Yt extends Vt{constructor(){super()}static nearestEndpoint(t,s,i,e){let n=t,r=Ft.pointToSegment(t,i,e),h=Ft.pointToSegment(s,i,e);return h<r&&(r=h,n=s),h=Ft.pointToSegment(i,t,s),h<r&&(r=h,n=i),h=Ft.pointToSegment(e,t,s),h<r&&(r=h,n=e),n}isInSegmentEnvelopes(t){const s=new O(this.H[0][0],this.H[0][1]),i=new O(this.H[1][0],this.H[1][1]);return s.contains(t)&&i.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],s=arguments[1],i=arguments[2];if(this.J=!1,O.intersects(s,i,t)&&0===Et.index(s,i,t)&&0===Et.index(i,s,t))return this.J=!0,(t.equals(s)||t.equals(i))&&(this.J=!1),this.U=Vt.POINT_INTERSECTION,null;this.U=Vt.NO_INTERSECTION}}intersection(t,s,i,e){let n=this.intersectionSafe(t,s,i,e);return this.isInSegmentEnvelopes(n)||(n=new m(Yt.nearestEndpoint(t,s,i,e))),null!==this.V&&this.V.makePrecise(n),n}checkDD(t,s,i,e,n){const r=It.intersection(t,s,i,e),h=this.isInSegmentEnvelopes(r);T.out.println("DD in env = "+h+"  --------------------- "+r),n.distance(r)>1e-4&&T.out.println("Distance = "+n.distance(r))}intersectionSafe(t,s,i,e){let n=Gt.intersection(t,s,i,e);return null===n&&(n=Yt.nearestEndpoint(t,s,i,e)),n}computeCollinearIntersection(t,s,i,e){const n=O.intersects(t,s,i),r=O.intersects(t,s,e),h=O.intersects(i,e,t),o=O.intersects(i,e,s);return n&&r?(this.W[0]=i,this.W[1]=e,Vt.COLLINEAR_INTERSECTION):h&&o?(this.W[0]=t,this.W[1]=s,Vt.COLLINEAR_INTERSECTION):n&&h?(this.W[0]=i,this.W[1]=t,!i.equals(t)||r||o?Vt.COLLINEAR_INTERSECTION:Vt.POINT_INTERSECTION):n&&o?(this.W[0]=i,this.W[1]=s,!i.equals(s)||r||h?Vt.COLLINEAR_INTERSECTION:Vt.POINT_INTERSECTION):r&&h?(this.W[0]=e,this.W[1]=t,!e.equals(t)||n||o?Vt.COLLINEAR_INTERSECTION:Vt.POINT_INTERSECTION):r&&o?(this.W[0]=e,this.W[1]=s,!e.equals(s)||n||h?Vt.COLLINEAR_INTERSECTION:Vt.POINT_INTERSECTION):Vt.NO_INTERSECTION}computeIntersect(t,s,i,e){if(this.J=!1,!O.intersects(t,s,i,e))return Vt.NO_INTERSECTION;const n=Et.index(t,s,i),r=Et.index(t,s,e);if(n>0&&r>0||n<0&&r<0)return Vt.NO_INTERSECTION;const h=Et.index(i,e,t),o=Et.index(i,e,s);return h>0&&o>0||h<0&&o<0?Vt.NO_INTERSECTION:0===n&&0===r&&0===h&&0===o?this.computeCollinearIntersection(t,s,i,e):(0===n||0===r||0===h||0===o?(this.J=!1,t.equals2D(i)||t.equals2D(e)?this.W[0]=t:s.equals2D(i)||s.equals2D(e)?this.W[0]=s:0===n?this.W[0]=new m(i):0===r?this.W[0]=new m(e):0===h?this.W[0]=new m(t):0===o&&(this.W[0]=new m(s))):(this.J=!0,this.W[0]=this.intersection(t,s,i,e)),Vt.POINT_INTERSECTION)}}class jt{constructor(){jt.constructor_.apply(this,arguments)}static constructor_(){this.st=null,this.it=0,this.et=!1;const t=arguments[0];this.st=t}static locatePointInRing(){if(arguments[0]instanceof m&&s(arguments[1],V)){const t=arguments[1],s=new jt(arguments[0]),i=new m,e=new m;for(let n=1;n<t.size();n++)if(t.getCoordinate(n,i),t.getCoordinate(n-1,e),s.countSegment(i,e),s.isOnSegment())return s.getLocation();return s.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],s=new jt(arguments[0]);for(let i=1;i<t.length;i++){const e=t[i],n=t[i-1];if(s.countSegment(e,n),s.isOnSegment())return s.getLocation()}return s.getLocation()}}getLocation(){return this.et?qt.BOUNDARY:this.it%2==1?qt.INTERIOR:qt.EXTERIOR}isPointInPolygon(){return this.getLocation()!==qt.EXTERIOR}isOnSegment(){return this.et}countSegment(t,s){if(t.x<this.st.x&&s.x<this.st.x)return null;if(this.st.x===s.x&&this.st.y===s.y)return this.et=!0,null;if(t.y===this.st.y&&s.y===this.st.y){let i=t.x,e=s.x;return i>e&&(i=s.x,e=t.x),this.st.x>=i&&this.st.x<=e&&(this.et=!0),null}if(t.y>this.st.y&&s.y<=this.st.y||s.y>this.st.y&&t.y<=this.st.y){let i=Et.index(t,s,this.st);if(i===Et.COLLINEAR)return this.et=!0,null;s.y<t.y&&(i=-i),i===Et.LEFT&&this.it++}}}class Xt{static isInRing(t,s){return Xt.locateInRing(t,s)!==qt.EXTERIOR}static locateInRing(t,s){return jt.locatePointInRing(t,s)}static isOnLine(){if(arguments[0]instanceof m&&s(arguments[1],V)){const t=arguments[0],s=arguments[1],i=new Yt,e=new m,n=new m,r=s.size();for(let h=1;h<r;h++)if(s.getCoordinate(h-1,e),s.getCoordinate(h,n),i.computeIntersection(t,e,n),i.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],s=arguments[1],i=new Yt;for(let e=1;e<s.length;e++){const n=s[e-1],r=s[e];if(i.computeIntersection(t,n,r),i.hasIntersection())return!0}return!1}}}class Ut extends l{constructor(t,s){super(s?t+" [ "+s+" ]":t),this.pt=s?new m(s):void 0,this.name=Object.keys({TopologyException:Ut})[0]}getCoordinate(){return this.pt}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Bt.ON]=t}else if(arguments[0]instanceof Zt){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let s=0;s<this.location.length;s++)this.location[s]=t.location[s]}}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.init(3),this.location[Bt.ON]=t,this.location[Bt.LEFT]=s,this.location[Bt.RIGHT]=i}}setAllLocations(t){for(let s=0;s<this.location.length;s++)this.location[s]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let s=0;s<this.location.length;s++)this.location[s]===qt.NONE&&(this.location[s]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Bt.ON]=this.location[Bt.ON],t[Bt.LEFT]=qt.NONE,t[Bt.RIGHT]=qt.NONE,this.location=t}for(let s=0;s<this.location.length;s++)this.location[s]===qt.NONE&&s<t.location.length&&(this.location[s]=t.location[s])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Bt.LEFT];this.location[Bt.LEFT]=this.location[Bt.RIGHT],this.location[Bt.RIGHT]=t}get(t){return t<this.location.length?this.location[t]:qt.NONE}isEqualOnSide(t,s){return this.location[s]===t.location[s]}allPositionsEqual(t){for(let s=0;s<this.location.length;s++)if(this.location[s]!==t)return!1;return!0}toString(){const t=new yt;return this.location.length>1&&t.append(qt.toLocationSymbol(this.location[Bt.LEFT])),t.append(qt.toLocationSymbol(this.location[Bt.ON])),this.location.length>1&&t.append(qt.toLocationSymbol(this.location[Bt.RIGHT])),t.toString()}setLocations(t,s,i){this.location[Bt.ON]=t,this.location[Bt.LEFT]=s,this.location[Bt.RIGHT]=i}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Bt.ON,t)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.location[t]=s}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(qt.NONE)}}class Ht{constructor(){Ht.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Zt(t),this.elt[1]=new Zt(t)}else if(arguments[0]instanceof Ht){const t=arguments[0];this.elt[0]=new Zt(t.elt[0]),this.elt[1]=new Zt(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.elt[0]=new Zt(qt.NONE),this.elt[1]=new Zt(qt.NONE),this.elt[t].setLocation(s)}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.elt[0]=new Zt(t,s,i),this.elt[1]=new Zt(t,s,i)}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];this.elt[0]=new Zt(qt.NONE,qt.NONE,qt.NONE),this.elt[1]=new Zt(qt.NONE,qt.NONE,qt.NONE),this.elt[t].setLocations(s,i,e)}}static toLineLabel(t){const s=new Ht(qt.NONE);for(let i=0;i<2;i++)s.setLocation(i,t.getLocation(i));return s}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,s){this.elt[t].setAllLocations(s)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.elt[t].setAllLocationsIfNull(s)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let s=0;s<2;s++)null===this.elt[s]&&null!==t.elt[s]?this.elt[s]=new Zt(t.elt[s]):this.elt[s].merge(t.elt[s])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Bt.ON)}if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.elt[t].get(s)}}toString(){const t=new yt;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}setLocation(){if(2===arguments.length){const t=arguments[0],s=arguments[1];this.elt[t].setLocation(Bt.ON,s)}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.elt[t].setLocation(s,i)}}isEqualOnSide(t,s){return this.elt[0].isEqualOnSide(t.elt[0],s)&&this.elt[1].isEqualOnSide(t.elt[1],s)}allPositionsEqual(t,s){return this.elt[t].allPositionsEqual(s)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Zt(this.elt[t].location[0]))}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}}class Wt{constructor(){Wt.constructor_.apply(this,arguments)}static constructor_(){if(this.nt=null,this.rt=-1,this.ht=new C,this.ot=new C,this.ut=new Ht(qt.NONE),this.ct=null,this.ft=null,this.G=null,this.F=new C,this.dt=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.dt=s,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this.ct)return null;const t=new Array(this.ot.size()).fill(null);for(let s=0;s<this.ot.size();s++)t[s]=this.ot.get(s);this.ct=this.dt.createLinearRing(t),this.ft=Et.isCCW(this.ct.getCoordinates())}isIsolated(){return 1===this.ut.getGeometryCount()}computePoints(t){this.nt=t;let s=t,i=!0;do{if(null===s)throw new Ut("Found null DirectedEdge");if(s.getEdgeRing()===this)throw new Ut("Directed Edge visited twice during ring-building at "+s.getCoordinate());this.ht.add(s);const t=s.getLabel();a.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(s.getEdge(),s.isForward(),i),i=!1,this.setEdgeRing(s,this),s=this.getNext(s)}while(s!==this.nt)}getLinearRing(){return this.ct}getCoordinate(t){return this.ot.get(t)}computeMaxNodeDegree(){this.rt=0;let t=this.nt;do{const s=t.getNode().getEdges().getOutgoingDegree(this);s>this.rt&&(this.rt=s),t=this.getNext(t)}while(t!==this.nt);this.rt*=2}addPoints(t,s,i){const e=t.getCoordinates();if(s){let t=1;i&&(t=0);for(let s=t;s<e.length;s++)this.ot.add(e[s])}else{let t=e.length-2;i&&(t=e.length-1);for(let s=t;s>=0;s--)this.ot.add(e[s])}}containsPoint(t){const s=this.getLinearRing();if(!s.getEnvelopeInternal().contains(t))return!1;if(!Xt.isInRing(t,s.getCoordinates()))return!1;for(let i=this.F.iterator();i.hasNext();)if(i.next().containsPoint(t))return!1;return!0}getMaxNodeDegree(){return this.rt<0&&this.computeMaxNodeDegree(),this.rt}setShell(t){this.G=t,null!==t&&t.addHole(this)}toPolygon(t){const s=new Array(this.F.size()).fill(null);for(let i=0;i<this.F.size();i++)s[i]=this.F.get(i).getLinearRing();return t.createPolygon(this.getLinearRing(),s)}isHole(){return this.ft}setInResult(){let t=this.nt;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this.nt)}addHole(t){this.F.add(t)}isShell(){return null===this.G}getLabel(){return this.ut}getEdges(){return this.ht}getShell(){return this.G}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],s=arguments[0].getLocation(t,Bt.RIGHT);if(s===qt.NONE)return null;if(this.ut.getLocation(t)===qt.NONE)return this.ut.setLocation(t,s),null}}}class Kt extends Wt{constructor(){super(),Kt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];Wt.constructor_.call(this,t,s)}getNext(t){return t.getNextMin()}setEdgeRing(t,s){t.setMinEdgeRing(s)}}class Qt extends Wt{constructor(){super(),Qt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];Wt.constructor_.call(this,t,s)}linkDirectedEdgesForMinimalEdgeRings(){let t=this.nt;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.nt)}buildMinimalRings(){const t=new C;let s=this.nt;do{if(null===s.getMinEdgeRing()){const i=new Kt(s,this.dt);t.add(i)}s=s.getNext()}while(s!==this.nt);return t}getNext(t){return t.getNext()}setEdgeRing(t,s){t.setEdgeRing(s)}}class Jt{locate(t){}}class $t{hasNext(){}next(){}remove(){}}class ts{constructor(){ts.constructor_.apply(this,arguments)}static constructor_(){this.wt=null,this.yt=null,this.bt=null,this.It=null,this.Et=null;const t=arguments[0];this.wt=t,this.yt=!0,this.It=0,this.bt=t.getNumGeometries()}static isAtomic(t){return!(t instanceof et)}next(){if(this.yt)return this.yt=!1,ts.isAtomic(this.wt)&&this.It++,this.wt;if(null!==this.Et){if(this.Et.hasNext())return this.Et.next();this.Et=null}if(this.It>=this.bt)throw new A;const t=this.wt.getGeometryN(this.It++);return t instanceof et?(this.Et=new ts(t),this.Et.next()):t}hasNext(){if(this.yt)return!0;if(null!==this.Et){if(this.Et.hasNext())return!0;this.Et=null}return!(this.It>=this.bt)}remove(){throw new E(this.getClass().getName())}get interfaces_(){return[$t]}}class ss{constructor(){ss.constructor_.apply(this,arguments)}static constructor_(){this.Mt=null;const t=arguments[0];this.Mt=t}static locatePointInPolygon(t,s){if(s.isEmpty())return qt.EXTERIOR;const i=s.getExteriorRing(),e=ss.locatePointInRing(t,i);if(e!==qt.INTERIOR)return e;for(let n=0;n<s.getNumInteriorRing();n++){const i=s.getInteriorRingN(n),e=ss.locatePointInRing(t,i);if(e===qt.BOUNDARY)return qt.BOUNDARY;if(e===qt.INTERIOR)return qt.EXTERIOR}return qt.INTERIOR}static locatePointInRing(t,s){return s.getEnvelopeInternal().intersects(t)?Xt.locateInRing(t,s.getCoordinates()):qt.EXTERIOR}static isContained(t,s){return qt.EXTERIOR!==ss.locate(t,s)}static locate(t,s){return s.isEmpty()?qt.EXTERIOR:s.getEnvelopeInternal().intersects(t)?ss.locateInGeometry(t,s):qt.EXTERIOR}static containsPointInPolygon(t,s){return qt.EXTERIOR!==ss.locatePointInPolygon(t,s)}static locateInGeometry(t,s){if(s instanceof Mt)return ss.locatePointInPolygon(t,s);if(s instanceof et){const i=new ts(s);for(;i.hasNext();){const e=i.next();if(e!==s){const s=ss.locateInGeometry(t,e);if(s!==qt.EXTERIOR)return s}}}return qt.EXTERIOR}locate(t){return ss.locate(t,this.Mt)}get interfaces_(){return[Jt]}}class is extends ht{}function es(t){return null==t?0:t.color}function ns(t){return null==t?null:t.parent}function rs(t,s){null!==t&&(t.color=s)}function hs(t){return null==t?null:t.left}function os(t){return null==t?null:t.right}class us extends is{constructor(){super(),this.root_=null,this.size_=0}get(t){let s=this.root_;for(;null!==s;){const i=t.compareTo(s.key);if(i<0)s=s.left;else{if(!(i>0))return s.value;s=s.right}}return null}put(t,s){if(null===this.root_)return this.root_={key:t,value:s,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let i,e,n=this.root_;do{if(i=n,e=t.compareTo(n.key),e<0)n=n.left;else{if(!(e>0)){const t=n.value;return n.value=s,t}n=n.right}}while(null!==n);const r={key:t,left:null,right:null,value:s,parent:i,color:0,getValue(){return this.value},getKey(){return this.key}};return e<0?i.left=r:i.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let s;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)ns(t)===hs(ns(ns(t)))?(s=os(ns(ns(t))),1===es(s)?(rs(ns(t),0),rs(s,0),rs(ns(ns(t)),1),t=ns(ns(t))):(t===os(ns(t))&&(t=ns(t),this.rotateLeft(t)),rs(ns(t),0),rs(ns(ns(t)),1),this.rotateRight(ns(ns(t))))):(s=hs(ns(ns(t))),1===es(s)?(rs(ns(t),0),rs(s,0),rs(ns(ns(t)),1),t=ns(ns(t))):(t===hs(ns(t))&&(t=ns(t),this.rotateRight(t)),rs(ns(t),0),rs(ns(ns(t)),1),this.rotateLeft(ns(ns(t)))));this.root_.color=0}values(){const t=new C;let s=this.getFirstEntry();if(null!==s)for(t.add(s.value);null!==(s=us.successor(s));)t.add(s.value);return t}entrySet(){const t=new ot;let s=this.getFirstEntry();if(null!==s)for(t.add(s);null!==(s=us.successor(s));)t.add(s);return t}rotateLeft(t){if(null!=t){const s=t.right;t.right=s.left,null!=s.left&&(s.left.parent=t),s.parent=t.parent,null==t.parent?this.root_=s:t.parent.left===t?t.parent.left=s:t.parent.right=s,s.left=t,t.parent=s}}rotateRight(t){if(null!=t){const s=t.left;t.left=s.right,null!=s.right&&(s.right.parent=t),s.parent=t.parent,null==t.parent?this.root_=s:t.parent.right===t?t.parent.right=s:t.parent.left=s,s.right=t,t.parent=s}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let s;if(null===t)return null;if(null!==t.right){for(s=t.right;null!==s.left;)s=s.left;return s}{s=t.parent;let i=t;for(;null!==s&&i===s.right;)i=s,s=s.parent;return s}}size(){return this.size_}containsKey(t){let s=this.root_;for(;null!==s;){const i=t.compareTo(s.key);if(i<0)s=s.left;else{if(!(i>0))return!0;s=s.right}}return!1}}class ls{constructor(){ls.constructor_.apply(this,arguments)}static constructor_(){this.Nt=new us,this.xt=null,this.At=[qt.NONE,qt.NONE]}getNextCW(t){this.getEdges();const s=this.xt.indexOf(t);let i=s-1;return 0===s&&(i=this.xt.size()-1),this.xt.get(i)}propagateSideLabels(t){let s=qt.NONE;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel();i.isArea(t)&&i.getLocation(t,Bt.LEFT)!==qt.NONE&&(s=i.getLocation(t,Bt.LEFT))}if(s===qt.NONE)return null;let i=s;for(let e=this.iterator();e.hasNext();){const s=e.next(),n=s.getLabel();if(n.getLocation(t,Bt.ON)===qt.NONE&&n.setLocation(t,Bt.ON,i),n.isArea(t)){const e=n.getLocation(t,Bt.LEFT),r=n.getLocation(t,Bt.RIGHT);if(r!==qt.NONE){if(r!==i)throw new Ut("side location conflict",s.getCoordinate());e===qt.NONE&&a.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),i=e}else a.isTrue(n.getLocation(t,Bt.LEFT)===qt.NONE,"found single null side"),n.setLocation(t,Bt.RIGHT,i),n.setLocation(t,Bt.LEFT,i)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}checkAreaLabelsConsistent(t){const s=this.getEdges();if(s.size()<=0)return!0;const i=s.size()-1,e=s.get(i).getLabel().getLocation(t,Bt.LEFT);a.isTrue(e!==qt.NONE,"Found unlabelled area edge");let n=e;for(let r=this.iterator();r.hasNext();){const s=r.next().getLabel();a.isTrue(s.isArea(t),"Found non-area edge");const i=s.getLocation(t,Bt.LEFT),e=s.getLocation(t,Bt.RIGHT);if(i===e)return!1;if(e!==n)return!1;n=i}return!0}findIndex(t){this.iterator();for(let s=0;s<this.xt.size();s++)if(this.xt.get(s)===t)return s;return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this.xt&&(this.xt=new C(this.Nt.values())),this.xt}getLocation(t,s,i){return this.At[t]===qt.NONE&&(this.At[t]=ss.locate(s,i[t].getGeometry())),this.At[t]}toString(){const t=new yt;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let s=this.iterator();s.hasNext();){const i=s.next();t.append(i),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let s=this.iterator();s.hasNext();)s.next().computeLabel(t)}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const s=[!1,!1];for(let i=this.iterator();i.hasNext();){const t=i.next().getLabel();for(let i=0;i<2;i++)t.isLine(i)&&t.getLocation(i)===qt.BOUNDARY&&(s[i]=!0)}for(let i=this.iterator();i.hasNext();){const e=i.next(),n=e.getLabel();for(let i=0;i<2;i++)if(n.isAnyNull(i)){let r=qt.NONE;if(s[i])r=qt.EXTERIOR;else{const s=e.getCoordinate();r=this.getLocation(i,s,t)}n.setAllLocationsIfNull(i,r)}}}getDegree(){return this.Nt.size()}insertEdgeEnd(t,s){this.Nt.put(t,s),this.xt=null}print(t){T.out.println("EdgeEndStar:   "+this.getCoordinate());for(let s=this.iterator();s.hasNext();)s.next().print(t)}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}}class cs{static isNorthern(t){return t===cs.NE||t===cs.NW}static isOpposite(t,s){return t!==s&&2==(t-s+4)%4}static commonHalfPlane(t,s){if(t===s)return t;if(2==(t-s+4)%4)return-1;const i=t<s?t:s;return 0===i&&3===(t>s?t:s)?3:i}static isInHalfPlane(t,s){return s===cs.SE?t===cs.SE||t===cs.SW:t===s||t===s+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],s=arguments[1];if(0===t&&0===s)throw new n("Cannot compute the quadrant for point ( "+t+", "+s+" )");return t>=0?s>=0?cs.NE:cs.SE:s>=0?cs.NW:cs.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],s=arguments[1];if(s.x===t.x&&s.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return s.x>=t.x?s.y>=t.y?cs.NE:cs.SE:s.y>=t.y?cs.NW:cs.SW}}}cs.NE=0,cs.NW=1,cs.SW=2,cs.SE=3;class as extends ls{constructor(){super(),as.constructor_.apply(this,arguments)}static constructor_(){this.Ct=null,this.ut=null,this.St=1,this._t=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,s=null,i=this.St;for(let e=0;e<this.Ct.size();e++){const n=this.Ct.get(e),r=n.getSym();if(n.getLabel().isArea())switch(null===t&&n.isInResult()&&(t=n),i){case this.St:if(!r.isInResult())continue;s=r,i=this._t;break;case this._t:if(!n.isInResult())continue;s.setNext(n),i=this.St}}if(i===this._t){if(null===t)throw new Ut("no outgoing dirEdge found",this.getCoordinate());a.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),s.setNext(t)}}insert(t){const s=t;this.insertEdgeEnd(s,s)}getRightmostEdge(){const t=this.getEdges(),s=t.size();if(s<1)return null;const i=t.get(0);if(1===s)return i;const e=t.get(s-1),n=i.getQuadrant(),r=e.getQuadrant();return cs.isNorthern(n)&&cs.isNorthern(r)?i:cs.isNorthern(n)||cs.isNorthern(r)?0!==i.getDy()?i:0!==e.getDy()?e:(a.shouldNeverReachHere("found two horizontal edges incident on node"),null):e}updateLabelling(t){for(let s=this.iterator();s.hasNext();){const i=s.next().getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,s=null;for(let i=this.xt.size()-1;i>=0;i--){const e=this.xt.get(i),n=e.getSym();null===s&&(s=n),null!==t&&n.setNext(t),t=e}s.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],s=this.findIndex(t),i=t.getDepth(Bt.LEFT),e=t.getDepth(Bt.RIGHT),n=this.computeDepths(s+1,this.xt.size(),i);if(this.computeDepths(0,s,n)!==e)throw new Ut("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let s=arguments[2];for(let i=arguments[0];i<t;i++){const t=this.xt.get(i);t.setEdgeDepths(Bt.RIGHT,s),s=t.getDepth(Bt.LEFT)}return s}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const s=t.next();s.getLabel().merge(s.getSym().getLabel())}}linkMinimalDirectedEdges(t){let s=null,i=null,e=this.St;for(let n=this.Ct.size()-1;n>=0;n--){const r=this.Ct.get(n),h=r.getSym();switch(null===s&&r.getEdgeRing()===t&&(s=r),e){case this.St:if(h.getEdgeRing()!==t)continue;i=h,e=this._t;break;case this._t:if(r.getEdgeRing()!==t)continue;i.setNextMin(r),e=this.St}}e===this._t&&(a.isTrue(null!==s,"found null for first outgoing dirEdge"),a.isTrue(s.getEdgeRing()===t,"unable to link last incoming dirEdge"),i.setNextMin(s))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let s=this.iterator();s.hasNext();)s.next().isInResult()&&t++;return t}if(1===arguments.length){const t=arguments[0];let s=0;for(let i=this.iterator();i.hasNext();)i.next().getEdgeRing()===t&&s++;return s}}getLabel(){return this.ut}findCoveredLineEdges(){let t=qt.NONE;for(let i=this.iterator();i.hasNext();){const s=i.next(),e=s.getSym();if(!s.isLineEdge()){if(s.isInResult()){t=qt.INTERIOR;break}if(e.isInResult()){t=qt.EXTERIOR;break}}}if(t===qt.NONE)return null;let s=t;for(let i=this.iterator();i.hasNext();){const t=i.next(),e=t.getSym();t.isLineEdge()?t.getEdge().setCovered(s===qt.INTERIOR):(t.isInResult()&&(s=qt.EXTERIOR),e.isInResult()&&(s=qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this.ut=new Ht(qt.NONE);for(let s=this.iterator();s.hasNext();){const t=s.next().getEdge().getLabel();for(let s=0;s<2;s++){const i=t.getLocation(s);i!==qt.INTERIOR&&i!==qt.BOUNDARY||this.ut.setLocation(s,qt.INTERIOR)}}}print(t){T.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let s=this.iterator();s.hasNext();){const i=s.next();t.print("out "),i.print(t),t.println(),t.print("in "),i.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this.Ct)return this.Ct;this.Ct=new C;for(let t=this.iterator();t.hasNext();){const s=t.next();(s.isInResult()||s.getSym().isInResult())&&this.Ct.add(s)}return this.Ct}}class fs{constructor(){fs.constructor_.apply(this,arguments)}static constructor_(){if(this.ut=null,this.Lt=!1,this.vt=!1,this.Pt=!1,this.Dt=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ut=t}}setVisited(t){this.Dt=t}setInResult(t){this.Lt=t}setLabel(t){this.ut=t}getLabel(){return this.ut}setCovered(t){this.vt=t,this.Pt=!0}updateIM(t){a.isTrue(this.ut.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isCovered(){return this.vt}isCoveredSet(){return this.Pt}isInResult(){return this.Lt}isVisited(){return this.Dt}}class ds extends fs{constructor(){super(),ds.constructor_.apply(this,arguments)}static constructor_(){this.Rt=null,this.ht=null;const t=arguments[0],s=arguments[1];this.Rt=t,this.ht=s,this.ut=new Ht(0,qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();)if(t.next().getEdge().isInResult())return!0;return!1}isIsolated(){return 1===this.ut.getGeometryCount()}getCoordinate(){return this.Rt}computeMergedLocation(t,s){let i=qt.NONE;if(i=this.ut.getLocation(s),!t.isNull(s)){const e=t.getLocation(s);i!==qt.BOUNDARY&&(i=e)}return i}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],s=arguments[1];null===this.ut?this.ut=new Ht(t,s):this.ut.setLocation(t,s)}}getEdges(){return this.ht}mergeLabel(){if(arguments[0]instanceof ds){const t=arguments[0];this.mergeLabel(t.ut)}else if(arguments[0]instanceof Ht){const t=arguments[0];for(let s=0;s<2;s++){const i=this.computeMergedLocation(t,s);this.ut.getLocation(s)===qt.NONE&&this.ut.setLocation(s,i)}}}add(t){this.ht.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this.ut)return null;let s=qt.NONE;null!==this.ut&&(s=this.ut.getLocation(t));let i=null;switch(s){case qt.BOUNDARY:i=qt.INTERIOR;break;case qt.INTERIOR:default:i=qt.BOUNDARY}this.ut.setLocation(t,i)}print(t){t.println("node "+this.Rt+" lbl: "+this.ut)}computeIM(t){}}class gs{createNode(t){return new ds(t,null)}}class ws extends gs{constructor(){super()}createNode(t){return new ds(t,new as)}}class ps{constructor(){ps.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new us,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}print(t){for(let s=this.iterator();s.hasNext();)s.next().print(t)}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const s=new C;for(let i=this.iterator();i.hasNext();){const e=i.next();e.getLabel().getLocation(t)===qt.BOUNDARY&&s.add(e)}return s}add(t){const s=t.getCoordinate();this.addNode(s).add(t)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let s=this.nodeMap.get(t);return null===s&&(s=this.nodeFact.createNode(t),this.nodeMap.put(t,s)),s}if(arguments[0]instanceof ds){const t=arguments[0],s=this.nodeMap.get(t.getCoordinate());return null===s?(this.nodeMap.put(t.getCoordinate(),t),t):(s.mergeLabel(t),s)}}}class ms{constructor(){ms.constructor_.apply(this,arguments)}static constructor_(){if(this.Tt=null,this.ut=null,this.Ot=null,this.kt=null,this.qt=null,this.Bt=null,this.Gt=null,this.Ft=null,1===arguments.length){const t=arguments[0];this.Tt=t}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];ms.constructor_.call(this,t,s,i,null)}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];ms.constructor_.call(this,t),this.init(s,i),this.ut=e}}compareDirection(t){return this.Bt===t.Bt&&this.Gt===t.Gt?0:this.Ft>t.Ft?1:this.Ft<t.Ft?-1:Et.index(t.kt,t.qt,this.qt)}getDy(){return this.Gt}print(t){const s=Math.atan2(this.Gt,this.Bt),i=this.getClass().getName(),e=i.lastIndexOf("."),n=i.substring(e+1);t.print("  "+n+": "+this.kt+" - "+this.qt+" "+this.Ft+":"+s+"   "+this.ut)}getLabel(){return this.ut}getEdge(){return this.Tt}toString(){const t=Math.atan2(this.Gt,this.Bt),s=this.getClass().getName(),i=s.lastIndexOf(".");return"  "+s.substring(i+1)+": "+this.kt+" - "+this.qt+" "+this.Ft+":"+t+"   "+this.ut}computeLabel(t){}init(t,s){this.kt=t,this.qt=s,this.Bt=s.x-t.x,this.Gt=s.y-t.y,this.Ft=cs.quadrant(this.Bt,this.Gt),a.isTrue(!(0===this.Bt&&0===this.Gt),"EdgeEnd with identical endpoints found")}getCoordinate(){return this.kt}setNode(t){this.Ot=t}compareTo(t){const s=t;return this.compareDirection(s)}getDirectedCoordinate(){return this.qt}getDx(){return this.Bt}getQuadrant(){return this.Ft}getNode(){return this.Ot}get interfaces_(){return[o]}}class ys extends ms{constructor(){super(),ys.constructor_.apply(this,arguments)}static constructor_(){this.zt=null,this.Lt=!1,this.Dt=!1,this.Vt=null,this.Yt=null,this.jt=null,this.Xt=null,this.Ut=null,this.Zt=[0,-999,-999];const t=arguments[0],s=arguments[1];if(ms.constructor_.call(this,t),this.zt=s,s)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const s=t.getNumPoints()-1;this.init(t.getCoordinate(s),t.getCoordinate(s-1))}this.computeDirectedLabel()}static depthFactor(t,s){return t===qt.EXTERIOR&&s===qt.INTERIOR?1:t===qt.INTERIOR&&s===qt.EXTERIOR?-1:0}setVisited(t){this.Dt=t}setDepth(t,s){if(-999!==this.Zt[t]&&this.Zt[t]!==s)throw new Ut("assigned depths do not match",this.getCoordinate());this.Zt[t]=s}isInteriorAreaEdge(){let t=!0;for(let s=0;s<2;s++)this.ut.isArea(s)&&this.ut.getLocation(s,Bt.LEFT)===qt.INTERIOR&&this.ut.getLocation(s,Bt.RIGHT)===qt.INTERIOR||(t=!1);return t}setNextMin(t){this.jt=t}print(t){super.print.call(this,t),t.print(" "+this.Zt[Bt.LEFT]+"/"+this.Zt[Bt.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this.Lt&&t.print(" inResult")}setMinEdgeRing(t){this.Ut=t}getSym(){return this.Vt}isForward(){return this.zt}setSym(t){this.Vt=t}setVisitedEdge(t){this.setVisited(t),this.Vt.setVisited(t)}getNextMin(){return this.jt}getDepth(t){return this.Zt[t]}computeDirectedLabel(){this.ut=new Ht(this.Tt.getLabel()),this.zt||this.ut.flip()}getNext(){return this.Yt}isLineEdge(){const t=this.ut.isLine(0)||this.ut.isLine(1),s=!this.ut.isArea(0)||this.ut.allPositionsEqual(0,qt.EXTERIOR),i=!this.ut.isArea(1)||this.ut.allPositionsEqual(1,qt.EXTERIOR);return t&&s&&i}setEdgeRing(t){this.Xt=t}getMinEdgeRing(){return this.Ut}getDepthDelta(){let t=this.Tt.getDepthDelta();return this.zt||(t=-t),t}setInResult(t){this.Lt=t}getEdge(){return this.Tt}printEdge(t){this.print(t),t.print(" "),this.zt?this.Tt.print(t):this.Tt.printReverse(t)}setEdgeDepths(t,s){let i=this.getEdge().getDepthDelta();this.zt||(i=-i);let e=1;t===Bt.LEFT&&(e=-1);const n=Bt.opposite(t),r=s+i*e;this.setDepth(t,s),this.setDepth(n,r)}getEdgeRing(){return this.Xt}isInResult(){return this.Lt}setNext(t){this.Yt=t}isVisited(){return this.Dt}}class bs{constructor(){bs.constructor_.apply(this,arguments)}static constructor_(){if(this.ht=new C,this.Ht=null,this.Wt=new C,0===arguments.length)this.Ht=new ps(new gs);else if(1===arguments.length){const t=arguments[0];this.Ht=new ps(t)}}static linkResultDirectedEdges(t){for(let s=t.iterator();s.hasNext();)s.next().getEdges().linkResultDirectedEdges()}printEdges(t){t.println("Edges:");for(let s=0;s<this.ht.size();s++){t.println("edge "+s+":");const i=this.ht.get(s);i.print(t),i.eiList.print(t)}}debugPrintln(t){T.out.println(t)}isBoundaryNode(t,s){const i=this.Ht.find(s);if(null===i)return!1;const e=i.getLabel();return null!==e&&e.getLocation(t)===qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this.Ht.iterator();t.hasNext();)t.next().getEdges().linkAllDirectedEdges()}debugPrint(t){T.out.print(t)}findEdgeEnd(t){for(let s=this.getEdgeEnds().iterator();s.hasNext();){const i=s.next();if(i.getEdge()===t)return i}return null}getNodes(){return this.Ht.values()}findEdge(t,s){for(let i=0;i<this.ht.size();i++){const e=this.ht.get(i),n=e.getCoordinates();if(t.equals(n[0])&&s.equals(n[1]))return e}return null}find(t){return this.Ht.find(t)}addNode(){if(arguments[0]instanceof ds){const t=arguments[0];return this.Ht.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.Ht.addNode(t)}}getNodeIterator(){return this.Ht.iterator()}linkResultDirectedEdges(){for(let t=this.Ht.iterator();t.hasNext();)t.next().getEdges().linkResultDirectedEdges()}matchInSameDirection(t,s,i,e){return!!t.equals(i)&&Et.index(t,s,e)===Et.COLLINEAR&&cs.quadrant(t,s)===cs.quadrant(i,e)}getEdgeEnds(){return this.Wt}getEdgeIterator(){return this.ht.iterator()}findEdgeInSameDirection(t,s){for(let i=0;i<this.ht.size();i++){const e=this.ht.get(i),n=e.getCoordinates();if(this.matchInSameDirection(t,s,n[0],n[1]))return e;if(this.matchInSameDirection(t,s,n[n.length-1],n[n.length-2]))return e}return null}insertEdge(t){this.ht.add(t)}addEdges(t){for(let s=t.iterator();s.hasNext();){const t=s.next();this.ht.add(t);const i=new ys(t,!0),e=new ys(t,!1);i.setSym(e),e.setSym(i),this.add(i),this.add(e)}}add(t){this.Ht.add(t),this.Wt.add(t)}}class Is{constructor(){Is.constructor_.apply(this,arguments)}static constructor_(){this.dt=new xt,this.Kt=null,this.Qt=null;const t=arguments[0];this.Kt=t}static findDifferentPoint(t,s){for(let i=0;i<t.length;i++)if(!t[i].equals(s))return t[i];return null}visitInteriorRing(t,s){if(t.isEmpty())return null;const i=t.getCoordinates(),e=i[0],n=Is.findDifferentPoint(i,e),r=s.findEdgeInSameDirection(e,n),h=s.findEdgeEnd(r);let o=null;h.getLabel().getLocation(0,Bt.RIGHT)===qt.INTERIOR?o=h:h.getSym().getLabel().getLocation(0,Bt.RIGHT)===qt.INTERIOR&&(o=h.getSym()),a.isTrue(null!==o,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(o)}visitShellInteriors(t,s){if(t instanceof Mt){const i=t;this.visitInteriorRing(i.getExteriorRing(),s)}if(t instanceof rt){const i=t;for(let t=0;t<i.getNumGeometries();t++){const e=i.getGeometryN(t);this.visitInteriorRing(e.getExteriorRing(),s)}}}getCoordinate(){return this.Qt}setInteriorEdgesInResult(t){for(let s=t.getEdgeEnds().iterator();s.hasNext();){const t=s.next();t.getLabel().getLocation(0,Bt.RIGHT)===qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const s=t;let i=t;do{a.isTrue(null!==i,"found null Directed Edge"),i.setVisited(!0),i=i.getNext()}while(i!==s)}buildEdgeRings(t){const s=new C;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.isInResult()&&null===t.getEdgeRing()){const i=new Qt(t,this.dt);i.linkDirectedEdgesForMinimalEdgeRings();const e=i.buildMinimalRings();s.addAll(e)}}return s}hasUnvisitedShellEdge(t){for(let s=0;s<t.size();s++){const i=t.get(s);if(i.isHole())continue;const e=i.getEdges();let n=e.get(0);if(n.getLabel().getLocation(0,Bt.RIGHT)===qt.INTERIOR)for(let t=0;t<e.size();t++)if(n=e.get(t),!n.isVisited())return this.Qt=n.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new C;this.Kt.computeSplitEdges(t);const s=new bs(new ws);s.addEdges(t),this.setInteriorEdgesInResult(s),s.linkResultDirectedEdges();const i=this.buildEdgeRings(s.getEdgeEnds());return this.visitShellInteriors(this.Kt.getGeometry(),s),!this.hasUnvisitedShellEdge(i)}}class Es{computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],s=new C;for(let i=t;i.hasNext();){const t=i.next();this.computeEdgeEnds(t,s)}return s}if(2===arguments.length){const t=arguments[0],s=arguments[1],i=t.getEdgeIntersectionList();i.addEndpoints();const e=i.iterator();let n=null,r=null;if(!e.hasNext())return null;let h=e.next();do{n=r,r=h,h=null,e.hasNext()&&(h=e.next()),null!==r&&(this.createEdgeEndForPrev(t,s,r,n),this.createEdgeEndForNext(t,s,r,h))}while(null!==r)}}createEdgeEndForNext(t,s,i,e){const n=i.segmentIndex+1;if(n>=t.getNumPoints()&&null===e)return null;let r=t.getCoordinate(n);null!==e&&e.segmentIndex===i.segmentIndex&&(r=e.coord);const h=new ms(t,i.coord,r,new Ht(t.getLabel()));s.add(h)}createEdgeEndForPrev(t,s,i,e){let n=i.segmentIndex;if(0===i.dist){if(0===n)return null;n--}let r=t.getCoordinate(n);null!==e&&e.segmentIndex>=n&&(r=e.coord);const h=new Ht(t.getLabel());h.flip();const o=new ms(t,i.coord,r,h);s.add(o)}}class Ms{}const Ns={reverseOrder:function(){return{compare:(t,s)=>s.compareTo(t)}},min:function(t){return Ns.sort(t),t.get(0)},sort:function(t,s){const i=t.toArray();s?it.sort(i,s):it.sort(i);const e=t.iterator();for(let n=0,r=i.length;n<r;n++)e.next(),e.set(i[n])},singletonList:function(t){const s=new C;return s.add(t),s}};class xs{constructor(){xs.constructor_.apply(this,arguments)}static constructor_(){this.Jt=!1,this.$t=!1,this.ts=!1,this.ss=null,this.es=null,this.ns=null,this.rs=null,this.hs=null,this.us=0,this.numTests=0,this.ls=null,this.cs=!1,this.fs=!1;const t=arguments[0],s=arguments[1],i=arguments[2];this.es=t,this.ns=s,this.rs=i}static isAdjacentSegments(t,s){return 1===Math.abs(t-s)}isTrivialIntersection(t,s,i,e){if(t===i&&1===this.es.getIntersectionNum()){if(xs.isAdjacentSegments(s,e))return!0;if(t.isClosed()){const i=t.getNumPoints()-1;if(0===s&&e===i||0===e&&s===i)return!0}}return!1}hasProperInteriorIntersection(){return this.ts}isBoundaryPointInternal(t,s){for(let i=s.iterator();i.hasNext();){const s=i.next().getCoordinate();if(t.isIntersection(s))return!0}return!1}hasProperIntersection(){return this.$t}hasIntersection(){return this.Jt}isDone(){return this.cs}isBoundaryPoint(t,s){return!(null===s||!this.isBoundaryPointInternal(t,s[0])&&!this.isBoundaryPointInternal(t,s[1]))}setBoundaryNodes(t,s){this.ls=new Array(2).fill(null),this.ls[0]=t,this.ls[1]=s}addIntersections(t,s,i,e){if(t===i&&s===e)return null;this.numTests++;const n=t.getCoordinates()[s],r=t.getCoordinates()[s+1],h=i.getCoordinates()[e],o=i.getCoordinates()[e+1];this.es.computeIntersection(n,r,h,o),this.es.hasIntersection()&&(this.rs&&(t.setIsolated(!1),i.setIsolated(!1)),this.us++,this.isTrivialIntersection(t,s,i,e)||(this.Jt=!0,!this.ns&&this.es.isProper()||(t.addIntersections(this.es,s,0),i.addIntersections(this.es,e,1)),this.es.isProper()&&(this.ss=this.es.getIntersection(0).copy(),this.$t=!0,this.fs&&(this.cs=!0),this.isBoundaryPoint(this.es,this.ls)||(this.ts=!0))))}getProperIntersectionPoint(){return this.ss}setIsDoneIfProperInt(t){this.fs=t}}class As{constructor(){As.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],s=arguments[1];this.mce=t,this.chainIndex=s}computeIntersections(t,s){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,s)}}class Cs{constructor(){Cs.constructor_.apply(this,arguments)}static constructor_(){if(this.ut=null,this.ds=null,this.gs=null,this.ws=null,this.ps=null,this.ys=null,2===arguments.length){const t=arguments[0],s=arguments[1];this.gs=Cs.DELETE,this.ds=t,this.ws=s}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.gs=Cs.INSERT,this.ut=t,this.ds=s,this.ys=i}}getObject(){return this.ys}getDeleteEventIndex(){return this.ps}isDelete(){return this.gs===Cs.DELETE}setDeleteEventIndex(t){this.ps=t}compareTo(t){const s=t;return this.ds<s.ds?-1:this.ds>s.ds?1:this.gs<s.gs?-1:this.gs>s.gs?1:0}getInsertEvent(){return this.ws}isInsert(){return this.gs===Cs.INSERT}isSameLabel(t){return null!==this.ut&&this.ut===t.ut}get interfaces_(){return[o]}}Cs.INSERT=1,Cs.DELETE=2;class Ss extends Ms{constructor(){super(),Ss.constructor_.apply(this,arguments)}static constructor_(){this.events=new C,this.nOverlaps=null}prepareEvents(){Ns.sort(this.events);for(let t=0;t<this.events.size();t++){const s=this.events.get(t);s.isDelete()&&s.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let s=0;s<this.events.size();s++){const i=this.events.get(s);if(i.isInsert()&&this.processOverlaps(s,i.getDeleteEventIndex(),i,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof xs&&s(arguments[0],x)&&s(arguments[1],x)){const t=arguments[0],s=arguments[1],i=arguments[2];this.addEdges(t,t),this.addEdges(s,s),this.computeIntersections(i)}else if("boolean"==typeof arguments[2]&&s(arguments[0],x)&&arguments[1]instanceof xs){const t=arguments[0],s=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(s)}}addEdge(t,s){const i=t.getMonotoneChainEdge(),e=i.getStartIndexes();for(let n=0;n<e.length-1;n++){const t=new As(i,n),e=new Cs(s,i.getMinX(n),t);this.events.add(e),this.events.add(new Cs(i.getMaxX(n),e))}}processOverlaps(t,s,i,e){const n=i.getObject();for(let r=t;r<s;r++){const t=this.events.get(r);if(t.isInsert()){const s=t.getObject();i.isSameLabel(t)||(n.computeIntersections(s,e),this.nOverlaps++)}}}addEdges(){if(1===arguments.length)for(let t=arguments[0].iterator();t.hasNext();){const s=t.next();this.addEdge(s,s)}else if(2===arguments.length){const t=arguments[1];for(let s=arguments[0].iterator();s.hasNext();){const i=s.next();this.addEdge(i,t)}}}}class _s{isInBoundary(t){}}class Ls{isInBoundary(t){return t%2==1}get interfaces_(){return[_s]}}class vs{isInBoundary(t){return t>0}get interfaces_(){return[_s]}}class Ps{isInBoundary(t){return t>1}get interfaces_(){return[_s]}}class Ds{isInBoundary(t){return 1===t}get interfaces_(){return[_s]}}_s.Mod2BoundaryNodeRule=Ls,_s.EndPointBoundaryNodeRule=vs,_s.MultiValentEndPointBoundaryNodeRule=Ps,_s.MonoValentEndPointBoundaryNodeRule=Ds,_s.MOD2_BOUNDARY_RULE=new Ls,_s.ENDPOINT_BOUNDARY_RULE=new vs,_s.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new Ps,_s.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new Ds,_s.OGC_SFS_BOUNDARY_RULE=_s.MOD2_BOUNDARY_RULE;class Rs{constructor(){Rs.constructor_.apply(this,arguments)}static constructor_(){if(this.bs=_s.OGC_SFS_BOUNDARY_RULE,this.Is=null,this.Es=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new n("Rule must be non-null");this.bs=t}}locateInPolygonRing(t,s){return s.getEnvelopeInternal().intersects(t)?Xt.locateInRing(t,s.getCoordinates()):qt.EXTERIOR}intersects(t,s){return this.locate(t,s)!==qt.EXTERIOR}updateLocationInfo(t){t===qt.INTERIOR&&(this.Is=!0),t===qt.BOUNDARY&&this.Es++}computeLocation(t,s){if(s instanceof pt&&this.updateLocationInfo(this.locateOnPoint(t,s)),s instanceof U)this.updateLocationInfo(this.locateOnLineString(t,s));else if(s instanceof Mt)this.updateLocationInfo(this.locateInPolygon(t,s));else if(s instanceof dt){const i=s;for(let s=0;s<i.getNumGeometries();s++){const e=i.getGeometryN(s);this.updateLocationInfo(this.locateOnLineString(t,e))}}else if(s instanceof rt){const i=s;for(let s=0;s<i.getNumGeometries();s++){const e=i.getGeometryN(s);this.updateLocationInfo(this.locateInPolygon(t,e))}}else if(s instanceof et){const i=new ts(s);for(;i.hasNext();){const e=i.next();e!==s&&this.computeLocation(t,e)}}}locateOnPoint(t,s){return s.getCoordinate().equals2D(t)?qt.INTERIOR:qt.EXTERIOR}locateOnLineString(t,s){if(!s.getEnvelopeInternal().intersects(t))return qt.EXTERIOR;const i=s.getCoordinateSequence();return s.isClosed()||!t.equals(i.getCoordinate(0))&&!t.equals(i.getCoordinate(i.size()-1))?Xt.isOnLine(t,i)?qt.INTERIOR:qt.EXTERIOR:qt.BOUNDARY}locateInPolygon(t,s){if(s.isEmpty())return qt.EXTERIOR;const i=s.getExteriorRing(),e=this.locateInPolygonRing(t,i);if(e===qt.EXTERIOR)return qt.EXTERIOR;if(e===qt.BOUNDARY)return qt.BOUNDARY;for(let n=0;n<s.getNumInteriorRing();n++){const i=s.getInteriorRingN(n),e=this.locateInPolygonRing(t,i);if(e===qt.INTERIOR)return qt.EXTERIOR;if(e===qt.BOUNDARY)return qt.BOUNDARY}return qt.INTERIOR}locate(t,s){return s.isEmpty()?qt.EXTERIOR:s instanceof U?this.locateOnLineString(t,s):s instanceof Mt?this.locateInPolygon(t,s):(this.Is=!1,this.Es=0,this.computeLocation(t,s),this.bs.isInBoundary(this.Es)?qt.BOUNDARY:this.Es>0||this.Is?qt.INTERIOR:qt.EXTERIOR)}}class Ts{visitItem(t){}}class Os{constructor(){Os.constructor_.apply(this,arguments)}static constructor_(){this.Ms=h.POSITIVE_INFINITY,this.bt=h.NEGATIVE_INFINITY}getMin(){return this.Ms}intersects(t,s){return!(this.Ms>s||this.bt<t)}getMax(){return this.bt}toString(){return zt.toLineString(new m(this.Ms,0),new m(this.bt,0))}}Os.NodeComparator=class{compare(t,s){const i=t,e=s,n=(i.Ms+i.bt)/2,r=(e.Ms+e.bt)/2;return n<r?-1:n>r?1:0}get interfaces_(){return[d]}};class ks extends Os{constructor(){super(),ks.constructor_.apply(this,arguments)}static constructor_(){this.Ns=null;const t=arguments[0],s=arguments[1],i=arguments[2];this.Ms=t,this.bt=s,this.Ns=i}query(t,s,i){if(!this.intersects(t,s))return null;i.visitItem(this.Ns)}}class qs extends Os{constructor(){super(),qs.constructor_.apply(this,arguments)}static constructor_(){this.xs=null,this.As=null;const t=arguments[0],s=arguments[1];this.xs=t,this.As=s,this.buildExtent(this.xs,this.As)}buildExtent(t,s){this.Ms=Math.min(t.Ms,s.Ms),this.bt=Math.max(t.bt,s.bt)}query(t,s,i){if(!this.intersects(t,s))return null;null!==this.xs&&this.xs.query(t,s,i),null!==this.As&&this.As.query(t,s,i)}}class Bs{constructor(){Bs.constructor_.apply(this,arguments)}static constructor_(){this.Cs=new C,this.Ss=null,this._s=0}buildTree(){Ns.sort(this.Cs,new Os.NodeComparator);let t=this.Cs,s=null,i=new C;for(;;){if(this.buildLevel(t,i),1===i.size())return i.get(0);s=t,t=i,i=s}}insert(t,s,i){if(null!==this.Ss)throw new wt("Index cannot be added to once it has been queried");this.Cs.add(new ks(t,s,i))}query(t,s,i){if(this.init(),null===this.Ss)return null;this.Ss.query(t,s,i)}buildRoot(){if(null!==this.Ss)return null;this.Ss=this.buildTree()}printNode(t){T.out.println(zt.toLineString(new m(t.Ms,this._s),new m(t.bt,this._s)))}init(){return null!==this.Ss||0===this.Cs.size()?null:void this.buildRoot()}buildLevel(t,s){this._s++,s.clear();for(let i=0;i<t.size();i+=2){const e=t.get(i);if(null===(i+1<t.size()?t.get(i):null))s.add(e);else{const e=new qs(t.get(i),t.get(i+1));s.add(e)}}}}class Gs{constructor(){Gs.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Gs.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Gs.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.p0=t,this.p1=s}else if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];Gs.constructor_.call(this,new m(t,s),new m(i,e))}}static midPoint(t,s){return new m((t.x+s.x)/2,(t.y+s.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Gs){const t=arguments[0],s=Et.index(this.p0,this.p1,t.p0),i=Et.index(this.p0,this.p1,t.p1);return s>=0&&i>=0||s<=0&&i<=0?Math.max(s,i):0}if(arguments[0]instanceof m){const t=arguments[0];return Et.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Gs.midPoint(this.p0,this.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,s){const i=this.p0.x+t*(this.p1.x-this.p0.x),e=this.p0.y+t*(this.p1.y-this.p0.y),n=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,h=Math.sqrt(n*n+r*r);let o=0,u=0;if(0!==s){if(h<=0)throw new wt("Cannot compute offset from zero-length line segment");o=s*n/h,u=s*r/h}return new m(i-u,e+o)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=s.x,this.p1.y=s.y}}segmentFraction(t){let s=this.projectionFactor(t);return s<0?s=0:(s>1||h.isNaN(s))&&(s=1),s}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}distance(){if(arguments[0]instanceof Gs){const t=arguments[0];return Ft.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return Ft.pointToSegment(t,this.p0,this.p1)}}equals(t){if(!(t instanceof Gs))return!1;const s=t;return this.p0.equals(s.p0)&&this.p1.equals(s.p1)}intersection(t){const s=new Yt;return s.computeIntersection(this.p0,this.p1,t.p0,t.p1),s.hasIntersection()?s.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const s=this.projectionFactor(t),i=new m;return i.x=this.p0.x+s*(this.p1.x-this.p0.x),i.y=this.p0.y+s*(this.p1.y-this.p0.y),i}if(arguments[0]instanceof Gs){const t=arguments[0],s=this.projectionFactor(t.p0),i=this.projectionFactor(t.p1);if(s>=1&&i>=1)return null;if(s<=0&&i<=0)return null;let e=this.project(t.p0);s<0&&(e=this.p0),s>1&&(e=this.p1);let n=this.project(t.p1);return i<0&&(n=this.p0),i>1&&(n=this.p1),new Gs(e,n)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return Ft.pointToLinePerpendicular(t,this.p0,this.p1)}closestPoint(t){const s=this.projectionFactor(t);return s>0&&s<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const s=this.p1.x-this.p0.x,i=this.p1.y-this.p0.y,e=s*s+i*i;return e<=0?h.NaN:((t.x-this.p0.x)*s+(t.y-this.p0.y)*i)/e}closestPoints(t){const s=this.intersection(t);if(null!==s)return[s,s];const i=new Array(2).fill(null);let e=h.MAX_VALUE,n=null;const r=this.closestPoint(t.p0);e=r.distance(t.p0),i[0]=r,i[1]=t.p0;const o=this.closestPoint(t.p1);n=o.distance(t.p1),n<e&&(e=n,i[0]=o,i[1]=t.p1);const u=t.closestPoint(this.p0);n=u.distance(this.p0),n<e&&(e=n,i[0]=this.p0,i[1]=u);const l=t.closestPoint(this.p1);return n=l.distance(this.p1),n<e&&(e=n,i[0]=this.p1,i[1]=l),i}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const s=t,i=this.p0.compareTo(s.p0);return 0!==i?i:this.p1.compareTo(s.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return Gt.intersection(this.p0,this.p1,t.p0,t.p1)}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const s=this.p1.getY()-this.p0.getY(),i=this.p0.getX()-this.p1.getX(),e=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),n=s*s+i*i,r=s*s-i*i,h=t.getX(),o=t.getY();return new m((-r*h-2*s*i*o-2*s*e)/n,(r*o-2*s*i*h-2*i*e)/n)}pointAlong(t){const s=new m;return s.x=this.p0.x+t*(this.p1.x-this.p0.x),s.y=this.p0.y+t*(this.p1.y-this.p0.y),s}hashCode(){let t=h.doubleToLongBits(this.p0.x);t^=31*h.doubleToLongBits(this.p0.y);const s=Math.trunc(t)^Math.trunc(t>>32);let i=h.doubleToLongBits(this.p1.x);return i^=31*h.doubleToLongBits(this.p1.y),s^Math.trunc(i)^Math.trunc(i>>32)}get interfaces_(){return[o,u]}}class Fs{constructor(){Fs.constructor_.apply(this,arguments)}static constructor_(){if(this.Ls=null,this.vs=!1,1===arguments.length){const t=arguments[0];this.Ls=t}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.Ls=t,this.vs=s}}static getLines(){if(1===arguments.length){const t=arguments[0];return Fs.getLines(t,!1)}if(2===arguments.length){if(s(arguments[0],M)&&s(arguments[1],M)){const t=arguments[1];for(let s=arguments[0].iterator();s.hasNext();){const i=s.next();Fs.getLines(i,t)}return t}if(arguments[0]instanceof G&&"boolean"==typeof arguments[1]){const t=arguments[0],s=arguments[1],i=new C;return t.apply(new Fs(i,s)),i}if(arguments[0]instanceof G&&s(arguments[1],M)){const t=arguments[0],s=arguments[1];return t instanceof U?s.add(t):t.apply(new Fs(s)),s}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&s(arguments[0],M)&&s(arguments[1],M)){const t=arguments[1],s=arguments[2];for(let i=arguments[0].iterator();i.hasNext();){const e=i.next();Fs.getLines(e,t,s)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof G&&s(arguments[1],M)){const t=arguments[1],s=arguments[2];return arguments[0].apply(new Fs(t,s)),t}}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(Fs.getLines(t))}if(2===arguments.length){const t=arguments[0],s=arguments[1];return t.getFactory().buildGeometry(Fs.getLines(t,s))}}filter(t){if(this.vs&&t instanceof Z){const s=t.getFactory().createLineString(t.getCoordinateSequence());return this.Ls.add(s),null}t instanceof U&&this.Ls.add(t)}setForceToLineString(t){this.vs=t}get interfaces_(){return[I]}}class zs{constructor(){zs.constructor_.apply(this,arguments)}static constructor_(){this.Ps=new C}getItems(){return this.Ps}visitItem(t){this.Ps.add(t)}get interfaces_(){return[Ts]}}class Vs{constructor(){Vs.constructor_.apply(this,arguments)}static constructor_(){this.Mt=null,this.It=null;const t=arguments[0];if(!(s(t,nt)||t instanceof Z))throw new n("Argument must be Polygonal or LinearRing");this.Mt=t}locate(t){null===this.It&&(this.It=new js(this.Mt),this.Mt=null);const s=new jt(t),i=new Ys(s);return this.It.query(t.y,t.y,i),s.getLocation()}get interfaces_(){return[Jt]}}class Ys{constructor(){Ys.constructor_.apply(this,arguments)}static constructor_(){this.Ds=null;const t=arguments[0];this.Ds=t}visitItem(t){const s=t;this.Ds.countSegment(s.getCoordinate(0),s.getCoordinate(1))}get interfaces_(){return[Ts]}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this.Rs=!1,this.It=new Bs;const t=arguments[0];t.isEmpty()?this.Rs=!0:this.init(t)}init(t){for(let s=Fs.getLines(t).iterator();s.hasNext();){const t=s.next().getCoordinates();this.addLine(t)}}addLine(t){for(let s=1;s<t.length;s++){const i=new Gs(t[s-1],t[s]),e=Math.min(i.p0.y,i.p1.y),n=Math.max(i.p0.y,i.p1.y);this.It.insert(e,n,i)}}query(){if(2===arguments.length){const t=arguments[0],s=arguments[1];if(this.Rs)return new C;const i=new zs;return this.It.query(t,s,i),i.getItems()}if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];if(this.Rs)return null;this.It.query(t,s,i)}}}Vs.SegmentVisitor=Ys,Vs.IntervalIndexedGeometry=js;class Xs{constructor(){Xs.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],s=arguments[1],i=arguments[2];this.coord=new m(t),this.segmentIndex=s,this.dist=i}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const s=t;return this.compare(s.segmentIndex,s.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,s){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<s?-1:this.dist>s?1:0}get interfaces_(){return[o]}}class Us{constructor(){Us.constructor_.apply(this,arguments)}static constructor_(){this.Ts=new us,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let s=this.iterator();s.hasNext();)s.next().print(t)}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,s){let i=s.segmentIndex-t.segmentIndex+2;const e=this.edge.pts[s.segmentIndex],n=s.dist>0||!s.coord.equals2D(e);n||i--;const r=new Array(i).fill(null);let h=0;r[h++]=new m(t.coord);for(let o=t.segmentIndex+1;o<=s.segmentIndex;o++)r[h++]=this.edge.pts[o];return n&&(r[h]=s.coord),new Js(r,new Ht(this.edge.ut))}add(t,s,i){const e=new Xs(t,s,i),n=this.Ts.get(e);return null!==n?n:(this.Ts.put(e,e),e)}isIntersection(t){for(let s=this.iterator();s.hasNext();)if(s.next().coord.equals(t))return!0;return!1}iterator(){return this.Ts.values().iterator()}addSplitEdges(t){this.addEndpoints();const s=this.iterator();let i=s.next();for(;s.hasNext();){const e=s.next(),n=this.createSplitEdge(i,e);t.add(n),i=e}}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){if(this.Os=null,0===arguments.length)this.Os=Array(3).fill().map(()=>Array(3)),this.setAll(B.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Zs.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Zs){const t=arguments[0];Zs.constructor_.call(this),this.Os[qt.INTERIOR][qt.INTERIOR]=t.Os[qt.INTERIOR][qt.INTERIOR],this.Os[qt.INTERIOR][qt.BOUNDARY]=t.Os[qt.INTERIOR][qt.BOUNDARY],this.Os[qt.INTERIOR][qt.EXTERIOR]=t.Os[qt.INTERIOR][qt.EXTERIOR],this.Os[qt.BOUNDARY][qt.INTERIOR]=t.Os[qt.BOUNDARY][qt.INTERIOR],this.Os[qt.BOUNDARY][qt.BOUNDARY]=t.Os[qt.BOUNDARY][qt.BOUNDARY],this.Os[qt.BOUNDARY][qt.EXTERIOR]=t.Os[qt.BOUNDARY][qt.EXTERIOR],this.Os[qt.EXTERIOR][qt.INTERIOR]=t.Os[qt.EXTERIOR][qt.INTERIOR],this.Os[qt.EXTERIOR][qt.BOUNDARY]=t.Os[qt.EXTERIOR][qt.BOUNDARY],this.Os[qt.EXTERIOR][qt.EXTERIOR]=t.Os[qt.EXTERIOR][qt.EXTERIOR]}}static isTrue(t){return t>=0||t===B.TRUE}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],s=arguments[1];return s===B.SYM_DONTCARE||s===B.SYM_TRUE&&(t>=0||t===B.TRUE)||s===B.SYM_FALSE&&t===B.FALSE||s===B.SYM_P&&t===B.P||s===B.SYM_L&&t===B.L||s===B.SYM_A&&t===B.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Zs(arguments[0]).matches(t)}}isIntersects(){return!this.isDisjoint()}set(){if(1===arguments.length){const t=arguments[0];for(let s=0;s<t.length;s++){const i=Math.trunc(s/3),e=s%3;this.Os[i][e]=B.toDimensionValue(t.charAt(s))}}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.Os[t][s]=i}}isContains(){return Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&this.Os[qt.EXTERIOR][qt.INTERIOR]===B.FALSE&&this.Os[qt.EXTERIOR][qt.BOUNDARY]===B.FALSE}isWithin(){return Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&this.Os[qt.INTERIOR][qt.EXTERIOR]===B.FALSE&&this.Os[qt.BOUNDARY][qt.EXTERIOR]===B.FALSE}isTouches(t,s){return t>s?this.isTouches(s,t):(t===B.A&&s===B.A||t===B.L&&s===B.L||t===B.L&&s===B.A||t===B.P&&s===B.A||t===B.P&&s===B.L)&&this.Os[qt.INTERIOR][qt.INTERIOR]===B.FALSE&&(Zs.isTrue(this.Os[qt.INTERIOR][qt.BOUNDARY])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.INTERIOR])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.BOUNDARY]))}isOverlaps(t,s){return t===B.P&&s===B.P||t===B.A&&s===B.A?Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&Zs.isTrue(this.Os[qt.INTERIOR][qt.EXTERIOR])&&Zs.isTrue(this.Os[qt.EXTERIOR][qt.INTERIOR]):t===B.L&&s===B.L&&1===this.Os[qt.INTERIOR][qt.INTERIOR]&&Zs.isTrue(this.Os[qt.INTERIOR][qt.EXTERIOR])&&Zs.isTrue(this.Os[qt.EXTERIOR][qt.INTERIOR])}isEquals(t,s){return t===s&&Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&this.Os[qt.INTERIOR][qt.EXTERIOR]===B.FALSE&&this.Os[qt.BOUNDARY][qt.EXTERIOR]===B.FALSE&&this.Os[qt.EXTERIOR][qt.INTERIOR]===B.FALSE&&this.Os[qt.EXTERIOR][qt.BOUNDARY]===B.FALSE}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let s=0;s<3;s++)for(let i=0;i<3;i++)if(!Zs.matches(this.Os[s][i],t.charAt(3*s+i)))return!1;return!0}add(t){for(let s=0;s<3;s++)for(let i=0;i<3;i++)this.setAtLeast(s,i,t.get(s,i))}isDisjoint(){return this.Os[qt.INTERIOR][qt.INTERIOR]===B.FALSE&&this.Os[qt.INTERIOR][qt.BOUNDARY]===B.FALSE&&this.Os[qt.BOUNDARY][qt.INTERIOR]===B.FALSE&&this.Os[qt.BOUNDARY][qt.BOUNDARY]===B.FALSE}isCrosses(t,s){return t===B.P&&s===B.L||t===B.P&&s===B.A||t===B.L&&s===B.A?Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&Zs.isTrue(this.Os[qt.INTERIOR][qt.EXTERIOR]):t===B.L&&s===B.P||t===B.A&&s===B.P||t===B.A&&s===B.L?Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])&&Zs.isTrue(this.Os[qt.EXTERIOR][qt.INTERIOR]):t===B.L&&s===B.L&&0===this.Os[qt.INTERIOR][qt.INTERIOR]}isCovers(){return(Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])||Zs.isTrue(this.Os[qt.INTERIOR][qt.BOUNDARY])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.INTERIOR])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.BOUNDARY]))&&this.Os[qt.EXTERIOR][qt.INTERIOR]===B.FALSE&&this.Os[qt.EXTERIOR][qt.BOUNDARY]===B.FALSE}isCoveredBy(){return(Zs.isTrue(this.Os[qt.INTERIOR][qt.INTERIOR])||Zs.isTrue(this.Os[qt.INTERIOR][qt.BOUNDARY])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.INTERIOR])||Zs.isTrue(this.Os[qt.BOUNDARY][qt.BOUNDARY]))&&this.Os[qt.INTERIOR][qt.EXTERIOR]===B.FALSE&&this.Os[qt.BOUNDARY][qt.EXTERIOR]===B.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let s=0;s<t.length;s++){const i=Math.trunc(s/3),e=s%3;this.setAtLeast(i,e,B.toDimensionValue(t.charAt(s)))}}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.Os[t][s]<i&&(this.Os[t][s]=i)}}setAtLeastIfValid(t,s,i){t>=0&&s>=0&&this.setAtLeast(t,s,i)}toString(){const t=new W("123456789");for(let s=0;s<3;s++)for(let i=0;i<3;i++)t.setCharAt(3*s+i,B.toDimensionSymbol(this.Os[s][i]));return t.toString()}setAll(t){for(let s=0;s<3;s++)for(let i=0;i<3;i++)this.Os[s][i]=t}get(t,s){return this.Os[t][s]}transpose(){let t=this.Os[1][0];return this.Os[1][0]=this.Os[0][1],this.Os[0][1]=t,t=this.Os[2][0],this.Os[2][0]=this.Os[0][2],this.Os[0][2]=t,t=this.Os[2][1],this.Os[2][1]=this.Os[1][2],this.Os[1][2]=t,this}get interfaces_(){return[f]}}class Hs{constructor(){Hs.constructor_.apply(this,arguments)}static constructor_(){this.Zt=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let s=0;s<3;s++)this.Zt[t][s]=Hs.NULL_VALUE}static depthAtLocation(t){return t===qt.EXTERIOR?0:t===qt.INTERIOR?1:Hs.NULL_VALUE}getDepth(t,s){return this.Zt[t][s]}setDepth(t,s,i){this.Zt[t][s]=i}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let s=0;s<3;s++)if(this.Zt[t][s]!==Hs.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this.Zt[t][1]===Hs.NULL_VALUE}if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.Zt[t][s]===Hs.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let s=this.Zt[t][1];this.Zt[t][2]<s&&(s=this.Zt[t][2]),s<0&&(s=0);for(let i=1;i<3;i++){let e=0;this.Zt[t][i]>s&&(e=1),this.Zt[t][i]=e}}}getDelta(t){return this.Zt[t][Bt.RIGHT]-this.Zt[t][Bt.LEFT]}getLocation(t,s){return this.Zt[t][s]<=0?qt.EXTERIOR:qt.INTERIOR}toString(){return"A: "+this.Zt[0][1]+","+this.Zt[0][2]+" B: "+this.Zt[1][1]+","+this.Zt[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let s=0;s<2;s++)for(let i=1;i<3;i++){const e=t.getLocation(s,i);e!==qt.EXTERIOR&&e!==qt.INTERIOR||(this.isNull(s,i)?this.Zt[s][i]=Hs.depthAtLocation(e):this.Zt[s][i]+=Hs.depthAtLocation(e))}}else if(3===arguments.length){const t=arguments[0],s=arguments[1];arguments[2]===qt.INTERIOR&&this.Zt[t][s]++}}}Hs.NULL_VALUE=-1;class Ws{constructor(){Ws.constructor_.apply(this,arguments)}static constructor_(){if(this.ks=null,this.qs=0,0===arguments.length)Ws.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this.ks=new Array(t).fill(null)}}size(){return this.qs}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this.qs+t.length),T.arraycopy(t,0,this.ks,this.qs,t.length),void(this.qs+=t.length))}ensureCapacity(t){if(t<=this.ks.length)return null;const s=Math.max(t,2*this.ks.length);this.ks=it.copyOf(this.ks,s)}toArray(){const t=new Array(this.qs).fill(null);return T.arraycopy(this.ks,0,t,0,this.qs),t}add(t){this.ensureCapacity(this.qs+1),this.ks[this.qs]=t,++this.qs}}class Ks{static toIntArray(t){const s=new Array(t.size()).fill(null);for(let i=0;i<s.length;i++)s[i]=t.get(i).intValue();return s}findChainEnd(t,s){const i=cs.quadrant(t[s],t[s+1]);let e=s+1;for(;e<t.length&&cs.quadrant(t[e-1],t[e])===i;)e++;return e-1}OLDgetChainStartIndices(t){let s=0;const i=new C;i.add(s);do{const e=this.findChainEnd(t,s);i.add(e),s=e}while(s<t.length-1);return Ks.toIntArray(i)}getChainStartIndices(t){let s=0;const i=new Ws(Math.trunc(t.length/2));i.add(s);do{const e=this.findChainEnd(t,s);i.add(e),s=e}while(s<t.length-1);return i.toArray()}}class Qs{constructor(){Qs.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const s=new Ks;this.startIndex=s.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const s=this.pts[this.startIndex[t]].x,i=this.pts[this.startIndex[t+1]].x;return s>i?s:i}getMinX(t){const s=this.pts[this.startIndex[t]].x,i=this.pts[this.startIndex[t+1]].x;return s<i?s:i}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],s,s.startIndex[i],s.startIndex[i+1],e)}else if(6===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=arguments[3],n=arguments[4],r=arguments[5];if(s-t===1&&n-e===1)return r.addIntersections(this.e,t,i.e,e),null;if(!this.overlaps(t,s,i,e,n))return null;const h=Math.trunc((t+s)/2),o=Math.trunc((e+n)/2);t<h&&(e<o&&this.computeIntersectsForChain(t,h,i,e,o,r),o<n&&this.computeIntersectsForChain(t,h,i,o,n,r)),h<s&&(e<o&&this.computeIntersectsForChain(h,s,i,e,o,r),o<n&&this.computeIntersectsForChain(h,s,i,o,n,r))}}overlaps(t,s,i,e,n){return O.intersects(this.pts[t],this.pts[s],i.pts[e],i.pts[n])}getStartIndexes(){return this.startIndex}computeIntersects(t,s){for(let i=0;i<this.startIndex.length-1;i++)for(let e=0;e<t.startIndex.length-1;e++)this.computeIntersectsForChain(i,t,e,s)}}class Js extends fs{constructor(){super(),Js.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this.Bs=null,this.eiList=new Us(this),this.k=null,this.Gs=null,this.Fs=!0,this.Zt=new Hs,this.zs=0,1===arguments.length){const t=arguments[0];Js.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.pts=t,this.ut=s}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Zs&&arguments[0]instanceof Ht))return super.updateIM.apply(this,arguments);{const t=arguments[0],s=arguments[1];s.setAtLeastIfValid(t.getLocation(0,Bt.ON),t.getLocation(1,Bt.ON),1),t.isArea()&&(s.setAtLeastIfValid(t.getLocation(0,Bt.LEFT),t.getLocation(1,Bt.LEFT),2),s.setAtLeastIfValid(t.getLocation(0,Bt.RIGHT),t.getLocation(1,Bt.RIGHT),2))}}getDepth(){return this.Zt}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Js(t,Ht.toLineLabel(this.ut))}setIsolated(t){this.Fs=t}setName(t){this.k=t}equals(t){if(!(t instanceof Js))return!1;const s=t;if(this.pts.length!==s.pts.length)return!1;let i=!0,e=!0,n=this.pts.length;for(let r=0;r<this.pts.length;r++)if(this.pts[r].equals2D(s.pts[r])||(i=!1),this.pts[r].equals2D(s.pts[--n])||(e=!1),!i&&!e)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}setDepthDelta(t){this.zs=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,s,i){for(let e=0;e<t.getIntersectionNum();e++)this.addIntersection(t,s,i,e)}isIsolated(){return this.Fs}getCoordinates(){return this.pts}print(t){t.print("edge "+this.k+": "),t.print("LINESTRING (");for(let s=0;s<this.pts.length;s++)s>0&&t.print(","),t.print(this.pts[s].x+" "+this.pts[s].y);t.print(")  "+this.ut+" "+this.zs)}computeIM(t){Js.updateIM(this.ut,t)}isCollapsed(){return!!this.ut.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])}getDepthDelta(){return this.zs}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this.k+": ");for(let s=this.pts.length-1;s>=0;s--)t.print(this.pts[s]+" ");t.println("")}getMonotoneChainEdge(){return null===this.Gs&&(this.Gs=new Qs(this)),this.Gs}getEnvelope(){if(null===this.Bs){this.Bs=new O;for(let t=0;t<this.pts.length;t++)this.Bs.expandToInclude(this.pts[t])}return this.Bs}addIntersection(t,s,i,e){const n=new m(t.getIntersection(e));let r=s,h=t.getEdgeDistance(i,e);const o=r+1;if(o<this.pts.length){const t=this.pts[o];n.equals2D(t)&&(r=o,h=0)}this.eiList.add(n,r,h)}toString(){const t=new W;t.append("edge "+this.k+": "),t.append("LINESTRING (");for(let s=0;s<this.pts.length;s++)s>0&&t.append(","),t.append(this.pts[s].x+" "+this.pts[s].y);return t.append(")  "+this.ut+" "+this.zs),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let s=0;s<this.pts.length;s++)if(!this.pts[s].equals2D(t.pts[s]))return!1;return!0}}class $s extends bs{constructor(){super(),$s.constructor_.apply(this,arguments)}static constructor_(){if(this.Vs=null,this.Ys=new lt,this.js=null,this.Xs=!0,this.Us=null,this.Zs=null,this.Hs=!1,this.Ws=null,this.Ks=null,this.Qs=new Rs,2===arguments.length){const t=arguments[0],s=arguments[1];$s.constructor_.call(this,t,s,_s.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];this.Us=t,this.Vs=s,this.js=i,null!==s&&this.add(s)}}static determineBoundary(t,s){return t.isInBoundary(s)?qt.BOUNDARY:qt.INTERIOR}insertBoundaryPoint(t,s){const i=this.Ht.addNode(s).getLabel();let e=1,n=qt.NONE;n=i.getLocation(t,Bt.ON),n===qt.BOUNDARY&&e++;const r=$s.determineBoundary(this.js,e);i.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.computeSelfNodes(t,s,!1)}if(3===arguments.length){const t=arguments[1],s=arguments[2],i=new xs(arguments[0],!0,!1);i.setIsDoneIfProperInt(s);const e=this.createEdgeSetIntersector(),n=this.Vs instanceof Z||this.Vs instanceof Mt||this.Vs instanceof rt,r=t||!n;return e.computeIntersections(this.ht,i,r),this.addSelfIntersectionNodes(this.Us),i}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),qt.EXTERIOR,qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s);this.addPolygonRing(i,qt.INTERIOR,qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const s=t.getCoordinates();this.insertPoint(this.Us,s[0],qt.BOUNDARY),this.insertPoint(this.Us,s[s.length-1],qt.BOUNDARY)}addLineString(t){const s=k.removeRepeatedPoints(t.getCoordinates());if(s.length<2)return this.Hs=!0,this.Ws=s[0],null;const i=new Js(s,new Ht(this.Us,qt.INTERIOR));this.Ys.put(t,i),this.insertEdge(i),a.isTrue(s.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.Us,s[0]),this.insertBoundaryPoint(this.Us,s[s.length-1])}getInvalidPoint(){return this.Ws}getBoundaryPoints(){const t=this.getBoundaryNodes(),s=new Array(t.size()).fill(null);let i=0;for(let e=t.iterator();e.hasNext();){const t=e.next();s[i++]=t.getCoordinate().copy()}return s}addSelfIntersectionNodes(t){for(let s=this.ht.iterator();s.hasNext();){const i=s.next(),e=i.getLabel().getLocation(t);for(let s=i.eiList.iterator();s.hasNext();){const i=s.next();this.addSelfIntersectionNode(t,i.coord,e)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof G))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof rt&&(this.Xs=!1),t instanceof Mt)this.addPolygon(t);else if(t instanceof U)this.addLineString(t);else if(t instanceof pt)this.addPoint(t);else if(t instanceof Nt)this.addCollection(t);else if(t instanceof dt)this.addCollection(t);else if(t instanceof rt)this.addCollection(t);else{if(!(t instanceof et))throw new E(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let s=0;s<t.getNumGeometries();s++){const i=t.getGeometryN(s);this.add(i)}}locate(t){return s(this.Vs,nt)&&this.Vs.getNumGeometries()>50?(null===this.Ks&&(this.Ks=new Vs(this.Vs)),this.Ks.locate(t)):this.Qs.locate(t,this.Vs)}findEdge(){if(1===arguments.length&&arguments[0]instanceof U){const t=arguments[0];return this.Ys.get(t)}return super.findEdge.apply(this,arguments)}computeSplitEdges(t){for(let s=this.ht.iterator();s.hasNext();)s.next().eiList.addSplitEdges(t)}computeEdgeIntersections(t,s,i){const e=new xs(s,i,!0);return e.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this.ht,t.ht,e),e}getGeometry(){return this.Vs}getBoundaryNodeRule(){return this.js}hasTooFewPoints(){return this.Hs}addPoint(){if(arguments[0]instanceof pt){const t=arguments[0].getCoordinate();this.insertPoint(this.Us,t,qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this.Us,t,qt.INTERIOR)}}getBoundaryNodes(){return null===this.Zs&&(this.Zs=this.Ht.getBoundaryNodes(this.Us)),this.Zs}addSelfIntersectionNode(t,s,i){if(this.isBoundaryNode(t,s))return null;i===qt.BOUNDARY&&this.Xs?this.insertBoundaryPoint(t,s):this.insertPoint(t,s,i)}addPolygonRing(t,s,i){if(t.isEmpty())return null;const e=k.removeRepeatedPoints(t.getCoordinates());if(e.length<4)return this.Hs=!0,this.Ws=e[0],null;let n=s,r=i;Et.isCCW(e)&&(n=i,r=s);const h=new Js(e,new Ht(this.Us,qt.BOUNDARY,n,r));this.Ys.put(t,h),this.insertEdge(h),this.insertPoint(this.Us,e[0],qt.BOUNDARY)}insertPoint(t,s,i){const e=this.Ht.addNode(s),n=e.getLabel();null===n?e.ut=new Ht(t,i):n.setLocation(t,i)}createEdgeSetIntersector(){return new Ss}}class ti extends ms{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){if(this.Js=new C,1===arguments.length){const t=arguments[0];ti.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ms.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Ht(t.getLabel())),this.insert(t)}}insert(t){this.Js.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this.ut);for(let s=this.iterator();s.hasNext();)s.next().print(t),t.println()}iterator(){return this.Js.iterator()}getEdgeEnds(){return this.Js}computeLabelOn(t,s){let i=0,e=!1;for(let r=this.iterator();r.hasNext();){const s=r.next().getLabel().getLocation(t);s===qt.BOUNDARY&&i++,s===qt.INTERIOR&&(e=!0)}let n=qt.NONE;e&&(n=qt.INTERIOR),i>0&&(n=$s.determineBoundary(s,i)),this.ut.setLocation(t,n)}computeLabelSide(t,s){for(let i=this.iterator();i.hasNext();){const e=i.next();if(e.getLabel().isArea()){const i=e.getLabel().getLocation(t,s);if(i===qt.INTERIOR)return this.ut.setLocation(t,s,qt.INTERIOR),null;i===qt.EXTERIOR&&this.ut.setLocation(t,s,qt.EXTERIOR)}}}getLabel(){return this.ut}computeLabelSides(t){this.computeLabelSide(t,Bt.LEFT),this.computeLabelSide(t,Bt.RIGHT)}updateIM(t){Js.updateIM(this.ut,t)}computeLabel(t){let s=!1;for(let i=this.iterator();i.hasNext();)i.next().getLabel().isArea()&&(s=!0);this.ut=s?new Ht(qt.NONE,qt.NONE,qt.NONE):new Ht(qt.NONE);for(let i=0;i<2;i++)this.computeLabelOn(i,t),s&&this.computeLabelSides(i)}}class si extends ls{constructor(){super()}updateIM(t){for(let s=this.iterator();s.hasNext();)s.next().updateIM(t)}insert(t){let s=this.Nt.get(t);null===s?(s=new ti(t),this.insertEdgeEnd(t,s)):s.insert(t)}}class ii extends ds{constructor(){super(),ii.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],s=arguments[1];ds.constructor_.call(this,t,s)}computeIM(t){t.setAtLeastIfValid(this.ut.getLocation(0),this.ut.getLocation(1),0)}updateIMFromEdges(t){this.ht.updateIM(t)}}class ei extends gs{constructor(){super()}createNode(t){return new ii(t,new si)}}class ni{constructor(){ni.constructor_.apply(this,arguments)}static constructor_(){this.Ht=new ps(new ei)}insertEdgeEnds(t){for(let s=t.iterator();s.hasNext();){const t=s.next();this.Ht.add(t)}}getNodeIterator(){return this.Ht.iterator()}copyNodesAndLabels(t,s){for(let i=t.getNodeIterator();i.hasNext();){const t=i.next();this.Ht.addNode(t.getCoordinate()).setLabel(s,t.getLabel().getLocation(s))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const s=(new Es).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(s)}computeIntersectionNodes(t,s){for(let i=t.getEdgeIterator();i.hasNext();){const t=i.next(),e=t.getLabel().getLocation(s);for(let i=t.getEdgeIntersectionList().iterator();i.hasNext();){const t=i.next(),n=this.Ht.addNode(t.coord);e===qt.BOUNDARY?n.setLabelBoundary(s):n.getLabel().isNull(s)&&n.setLabel(s,qt.INTERIOR)}}}}class ri{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){this.es=new Yt,this.Kt=null,this.$s=new ni,this.Ws=null;const t=arguments[0];this.Kt=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this.$s.getNodeIterator();t.hasNext();){const s=t.next();if(!s.getEdges().isAreaLabelsConsistent(this.Kt))return this.Ws=s.getCoordinate().copy(),!1}return!0}hasDuplicateRings(){for(let t=this.$s.getNodeIterator();t.hasNext();)for(let s=t.next().getEdges().iterator();s.hasNext();){const t=s.next();if(t.getEdgeEnds().size()>1)return this.Ws=t.getEdge().getCoordinate(0),!0}return!1}isNodeConsistentArea(){const t=this.Kt.computeSelfNodes(this.es,!0,!0);return t.hasProperIntersection()?(this.Ws=t.getProperIntersectionPoint(),!1):(this.$s.build(this.Kt),this.isNodeEdgeAreaLabelsConsistent())}getInvalidPoint(){return this.Ws}}class hi{getBounds(){}}class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){this.ti=null,this.Ns=null;const t=arguments[0],s=arguments[1];this.ti=t,this.Ns=s}getItem(){return this.Ns}getBounds(){return this.ti}get interfaces_(){return[hi,u]}}class ui{constructor(){this.si=new t((t,s)=>t.compareTo(s)<0)}poll(){return this.si.poll()}size(){return this.si.size}clear(){this.si=new t}peek(){return this.si.peek()}remove(){return this.si.poll()}isEmpty(){return this.si.isEmpty()}add(t){this.si.add(t)}}class li{query(){}insert(t,s){}remove(t,s){}}class ci{constructor(){ci.constructor_.apply(this,arguments)}static constructor_(){if(this.ii=new C,this.ti=null,this._s=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._s=t}}getLevel(){return this._s}addChildBoundable(t){a.isTrue(null===this.ti),this.ii.add(t)}isEmpty(){return this.ii.isEmpty()}getBounds(){return null===this.ti&&(this.ti=this.computeBounds()),this.ti}size(){return this.ii.size()}getChildBoundables(){return this.ii}get interfaces_(){return[hi,u]}}class ai{static distance(t,s,i,e){const n=i-t,r=e-s;return Math.sqrt(n*n+r*r)}static maximumDistance(t,s){const i=Math.min(t.getMinX(),s.getMinX()),e=Math.min(t.getMinY(),s.getMinY()),n=Math.max(t.getMaxX(),s.getMaxX()),r=Math.max(t.getMaxY(),s.getMaxY());return ai.distance(i,e,n,r)}static minMaxDistance(t,s){const i=t.getMinX(),e=t.getMinY(),n=t.getMaxX(),r=t.getMaxY(),h=s.getMinX(),o=s.getMinY(),u=s.getMaxX(),l=s.getMaxY();let c=ai.maxDistance(i,e,i,r,h,o,h,l);return c=Math.min(c,ai.maxDistance(i,e,i,r,h,o,u,o)),c=Math.min(c,ai.maxDistance(i,e,i,r,u,l,h,l)),c=Math.min(c,ai.maxDistance(i,e,i,r,u,l,u,o)),c=Math.min(c,ai.maxDistance(i,e,n,e,h,o,h,l)),c=Math.min(c,ai.maxDistance(i,e,n,e,h,o,u,o)),c=Math.min(c,ai.maxDistance(i,e,n,e,u,l,h,l)),c=Math.min(c,ai.maxDistance(i,e,n,e,u,l,u,o)),c=Math.min(c,ai.maxDistance(n,r,i,r,h,o,h,l)),c=Math.min(c,ai.maxDistance(n,r,i,r,h,o,u,o)),c=Math.min(c,ai.maxDistance(n,r,i,r,u,l,h,l)),c=Math.min(c,ai.maxDistance(n,r,i,r,u,l,u,o)),c=Math.min(c,ai.maxDistance(n,r,n,e,h,o,h,l)),c=Math.min(c,ai.maxDistance(n,r,n,e,h,o,u,o)),c=Math.min(c,ai.maxDistance(n,r,n,e,u,l,h,l)),c=Math.min(c,ai.maxDistance(n,r,n,e,u,l,u,o)),c}static maxDistance(t,s,i,e,n,r,h,o){let u=ai.distance(t,s,n,r);return u=Math.max(u,ai.distance(t,s,h,o)),u=Math.max(u,ai.distance(i,e,n,r)),u=Math.max(u,ai.distance(i,e,h,o)),u}}class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this.ei=null,this.ni=null,this.ri=null,this.hi=null;const t=arguments[0],s=arguments[1],i=arguments[2];this.ei=t,this.ni=s,this.hi=i,this.ri=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ci}maximumDistance(){return ai.maximumDistance(this.ei.getBounds(),this.ni.getBounds())}expandToQueue(t,s){const i=fi.isComposite(this.ei),e=fi.isComposite(this.ni);if(i&&e)return fi.area(this.ei)>fi.area(this.ni)?(this.expand(this.ei,this.ni,!1,t,s),null):(this.expand(this.ni,this.ei,!0,t,s),null);if(i)return this.expand(this.ei,this.ni,!1,t,s),null;if(e)return this.expand(this.ni,this.ei,!0,t,s),null;throw new n("neither boundable is composite")}isLeaves(){return!(fi.isComposite(this.ei)||fi.isComposite(this.ni))}getBoundable(t){return 0===t?this.ei:this.ni}getDistance(){return this.ri}distance(){return this.isLeaves()?this.hi.distance(this.ei,this.ni):this.ei.getBounds().distance(this.ni.getBounds())}compareTo(t){const s=t;return this.ri<s.ri?-1:this.ri>s.ri?1:0}expand(t,s,i,e,n){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let h=null;h=i?new fi(s,t,this.hi):new fi(t,s,this.hi),h.getDistance()<n&&e.add(h)}}get interfaces_(){return[o]}}class di{constructor(){di.constructor_.apply(this,arguments)}static constructor_(){if(this.Ss=null,this.oi=!1,this.ui=new C,this.li=null,0===arguments.length)di.constructor_.call(this,di.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];a.isTrue(t>1,"Node capacity must be greater than 1"),this.li=t}}static compareDoubles(t,s){return t>s?1:t<s?-1:0}queryInternal(){if(s(arguments[2],Ts)&&arguments[0]instanceof Object&&arguments[1]instanceof ci){const t=arguments[0],s=arguments[2],i=arguments[1].getChildBoundables();for(let e=0;e<i.size();e++){const n=i.get(e);this.getIntersectsOp().intersects(n.getBounds(),t)&&(n instanceof ci?this.queryInternal(t,n,s):n instanceof oi?s.visitItem(n.getItem()):a.shouldNeverReachHere())}}else if(s(arguments[2],x)&&arguments[0]instanceof Object&&arguments[1]instanceof ci){const t=arguments[0],s=arguments[2],i=arguments[1].getChildBoundables();for(let e=0;e<i.size();e++){const n=i.get(e);this.getIntersectsOp().intersects(n.getBounds(),t)&&(n instanceof ci?this.queryInternal(t,n,s):n instanceof oi?s.add(n.getItem()):a.shouldNeverReachHere())}}}insert(t,s){a.isTrue(!this.oi,"Cannot insert items into an STR packed R-tree after it has been built."),this.ui.add(new oi(t,s))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],s=new C;return this.boundablesAtLevel(t,this.Ss,s),s}if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];if(a.isTrue(t>-2),s.getLevel()===t)return i.add(s),null;for(let e=s.getChildBoundables().iterator();e.hasNext();){const s=e.next();s instanceof ci?this.boundablesAtLevel(t,s,i):(a.isTrue(s instanceof oi),-1===t&&i.add(s))}return null}}getRoot(){return this.build(),this.Ss}remove(){if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this.Ss.getBounds(),t)&&this.remove(t,this.Ss,s)}if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2];let e=this.removeItem(s,i);if(e)return!0;let n=null;for(let r=s.getChildBoundables().iterator();r.hasNext();){const s=r.next();if(this.getIntersectsOp().intersects(s.getBounds(),t)&&s instanceof ci&&(e=this.remove(t,s,i),e)){n=s;break}}return null!==n&&n.getChildBoundables().isEmpty()&&s.getChildBoundables().remove(n),e}}createHigherLevels(t,s){a.isTrue(!t.isEmpty());const i=this.createParentBoundables(t,s+1);return 1===i.size()?i.get(0):this.createHigherLevels(i,s+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.Ss));if(1===arguments.length){let t=0;for(let s=arguments[0].getChildBoundables().iterator();s.hasNext();){const i=s.next();if(i instanceof ci){const s=this.depth(i);s>t&&(t=s)}}return t+1}}createParentBoundables(t,s){a.isTrue(!t.isEmpty());const i=new C;i.add(this.createNode(s));const e=new C(t);Ns.sort(e,this.getComparator());for(let n=e.iterator();n.hasNext();){const t=n.next();this.lastNode(i).getChildBoundables().size()===this.getNodeCapacity()&&i.add(this.createNode(s)),this.lastNode(i).addChildBoundable(t)}return i}isEmpty(){return this.oi?this.Ss.isEmpty():this.ui.isEmpty()}getNodeCapacity(){return this.li}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.Ss));if(1===arguments.length){let t=0;for(let s=arguments[0].getChildBoundables().iterator();s.hasNext();){const i=s.next();i instanceof ci?t+=this.size(i):i instanceof oi&&(t+=1)}return t}}removeItem(t,s){let i=null;for(let e=t.getChildBoundables().iterator();e.hasNext();){const t=e.next();t instanceof oi&&t.getItem()===s&&(i=t)}return null!==i&&(t.getChildBoundables().remove(i),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this.Ss);return null===t?new C:t}if(1===arguments.length){const t=arguments[0],s=new C;for(let i=t.getChildBoundables().iterator();i.hasNext();){const t=i.next();if(t instanceof ci){const i=this.itemsTree(t);null!==i&&s.add(i)}else t instanceof oi?s.add(t.getItem()):a.shouldNeverReachHere()}return s.size()<=0?null:s}}query(){if(1===arguments.length){const t=arguments[0];this.build();const s=new C;return this.isEmpty()||this.getIntersectsOp().intersects(this.Ss.getBounds(),t)&&this.queryInternal(t,this.Ss,s),s}if(2===arguments.length){const t=arguments[0],s=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.Ss.getBounds(),t)&&this.queryInternal(t,this.Ss,s)}}build(){if(this.oi)return null;this.Ss=this.ui.isEmpty()?this.createNode(0):this.createHigherLevels(this.ui,-1),this.ui=null,this.oi=!0}get interfaces_(){return[u]}}di.IntersectsOp=function(){},di.DEFAULT_NODE_CAPACITY=10;class gi{distance(t,s){}}class wi extends di{constructor(){super(),wi.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)wi.constructor_.call(this,wi.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];di.constructor_.call(this,t)}}static getItems(t){const s=new Array(t.size()).fill(null);let i=0;for(;!t.isEmpty();){const e=t.poll();s[i]=e.getBoundable(0).getItem(),i++}return s}static avg(t,s){return(t+s)/2}static centreY(t){return wi.avg(t.getMinY(),t.getMaxY())}static centreX(t){return wi.avg(t.getMinX(),t.getMaxX())}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],s=arguments[1];if(t.isNull())return null;super.insert.call(this,t,s)}}getIntersectsOp(){return wi.intersectsOp}verticalSlices(t,s){const i=Math.trunc(Math.ceil(t.size()/s)),e=new Array(s).fill(null),n=t.iterator();for(let r=0;r<s;r++){e[r]=new C;let t=0;for(;n.hasNext()&&t<i;){const s=n.next();e[r].add(s),t++}}return e}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],s=arguments[1];super.query.call(this,t,s)}}getComparator(){return wi.yComparator}createParentBoundablesFromVerticalSlice(t,s){return super.createParentBoundables.call(this,t,s)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],s=arguments[1];return super.remove.call(this,t,s)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,s){a.isTrue(!t.isEmpty());const i=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),e=new C(t);Ns.sort(e,wi.xComparator);const n=this.verticalSlices(e,Math.trunc(Math.ceil(Math.sqrt(i))));return this.createParentBoundablesFromVerticalSlices(n,s)}nearestNeighbour(){if(1===arguments.length){if(s(arguments[0],gi)){const t=arguments[0];if(this.isEmpty())return null;const s=new fi(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(s)}if(arguments[0]instanceof fi){const t=arguments[0];let s=h.POSITIVE_INFINITY,i=null;const e=new ui;for(e.add(t);!e.isEmpty()&&s>0;){const t=e.poll(),n=t.getDistance();if(n>=s)break;t.isLeaves()?(s=n,i=t):t.expandToQueue(e,s)}return null===i?null:[i.getBoundable(0).getItem(),i.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],s=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const i=new fi(this.getRoot(),t.getRoot(),s);return this.nearestNeighbour(i)}if(3===arguments.length){const t=arguments[2],s=new oi(arguments[0],arguments[1]),i=new fi(this.getRoot(),s,t);return this.nearestNeighbour(i)[0]}if(4===arguments.length){const t=arguments[2],s=arguments[3],i=new oi(arguments[0],arguments[1]),e=new fi(this.getRoot(),i,t);return this.nearestNeighbourK(e,s)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],s=arguments[1];let i=h.POSITIVE_INFINITY;const e=new ui;for(e.add(t);!e.isEmpty();){const t=e.poll(),n=t.getDistance();if(n>s)return!1;if(t.maximumDistance()<=s)return!0;if(t.isLeaves()){if(i=n,i<=s)return!0}else t.expandToQueue(e,i)}return!1}if(3===arguments.length){const t=arguments[0],s=arguments[1],i=arguments[2],e=new fi(this.getRoot(),t.getRoot(),s);return this.isWithinDistance(e,i)}}createParentBoundablesFromVerticalSlices(t,s){a.isTrue(t.length>0);const i=new C;for(let e=0;e<t.length;e++)i.addAll(this.createParentBoundablesFromVerticalSlice(t[e],s));return i}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],s=arguments[1];return this.nearestNeighbourK(t,h.POSITIVE_INFINITY,s)}if(3===arguments.length){const t=arguments[0],s=arguments[2];let i=arguments[1];const e=new ui;e.add(t);const n=new ui;for(;!e.isEmpty()&&i>=0;){const t=e.poll(),r=t.getDistance();if(r>=i)break;t.isLeaves()?n.size()<s?n.add(t):(n.peek().getDistance()>r&&(n.poll(),n.add(t)),i=n.peek().getDistance()):t.expandToQueue(e,i)}return wi.getItems(n)}}createNode(t){return new pi(t)}get interfaces_(){return[li,u]}}class pi extends ci{constructor(){super(),pi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];ci.constructor_.call(this,t)}computeBounds(){let t=null;for(let s=this.getChildBoundables().iterator();s.hasNext();){const i=s.next();null===t?t=new O(i.getBounds()):t.expandToInclude(i.getBounds())}return t}}wi.STRtreeNode=pi,wi.xComparator=new class{get interfaces_(){return[d]}compare(t,s){return di.compareDoubles(wi.centreX(t.getBounds()),wi.centreX(s.getBounds()))}},wi.yComparator=new class{get interfaces_(){return[d]}compare(t,s){return di.compareDoubles(wi.centreY(t.getBounds()),wi.centreY(s.getBounds()))}},wi.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,s){return t.intersects(s)}},wi.DEFAULT_NODE_CAPACITY=10;class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this.ci=null,this.ai=new C,this.fi=new O,this.It=null,this.di=null;const t=arguments[0];this.ci=t}add(t){this.ai.add(t),this.fi.expandToInclude(t.getEnvelopeInternal())}getNestedPoint(){return this.di}buildIndex(){this.It=new wi;for(let t=0;t<this.ai.size();t++){const s=this.ai.get(t),i=s.getEnvelopeInternal();this.It.insert(i,s)}}isNonNested(){this.buildIndex();for(let t=0;t<this.ai.size();t++){const s=this.ai.get(t),i=s.getCoordinates(),e=this.It.query(s.getEnvelopeInternal());for(let t=0;t<e.size();t++){const n=e.get(t),r=n.getCoordinates();if(s===n)continue;if(!s.getEnvelopeInternal().intersects(n.getEnvelopeInternal()))continue;const h=bi.findPtNotNode(i,n,this.ci);if(null!==h&&Xt.isInRing(h,r))return this.di=h,!1}}return!0}}class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){if(this.gi=null,this.wi=null,1===arguments.length){const t=arguments[0];yi.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],s=arguments[1];this.gi=t,null!==s&&(this.wi=s.copy())}}getCoordinate(){return this.wi}getMessage(){return yi.errMsg[this.gi]}toString(){let t="";return null!==this.wi&&(t=" at or near point "+this.wi),this.getMessage()+t}getErrorType(){return this.gi}}yi.ERROR=0,yi.REPEATED_POINT=1,yi.HOLE_OUTSIDE_SHELL=2,yi.NESTED_HOLES=3,yi.DISCONNECTED_INTERIOR=4,yi.SELF_INTERSECTION=5,yi.RING_SELF_INTERSECTION=6,yi.NESTED_SHELLS=7,yi.DUPLICATE_RINGS=8,yi.TOO_FEW_POINTS=9,yi.INVALID_COORDINATE=10,yi.RING_NOT_CLOSED=11,yi.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this.pi=null,this.mi=!1,this.yi=null;const t=arguments[0];this.pi=t}static findPtNotNode(t,s,i){const e=i.findEdge(s).getEdgeIntersectionList();for(let n=0;n<t.length;n++){const s=t[n];if(!e.isIntersection(s))return s}return null}static isValid(){if(arguments[0]instanceof G)return new bi(arguments[0]).isValid();if(arguments[0]instanceof m){const t=arguments[0];return!(h.isNaN(t.x)||h.isInfinite(t.x)||h.isNaN(t.y)||h.isInfinite(t.y))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let s=0;s<t.length;s++)if(!bi.isValid(t[s]))return this.yi=new yi(yi.INVALID_COORDINATE,t[s]),null}else if(arguments[0]instanceof Mt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this.yi)return null;for(let s=0;s<t.getNumInteriorRing();s++)if(this.checkInvalidCoordinates(t.getInteriorRingN(s).getCoordinates()),null!==this.yi)return null}}checkHolesNotNested(t,s){if(t.getNumInteriorRing()<=0)return null;const i=new mi(s);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||i.add(s)}i.isNonNested()||(this.yi=new yi(yi.NESTED_HOLES,i.getNestedPoint()))}checkConsistentArea(t){const s=new ri(t);if(!s.isNodeConsistentArea())return this.yi=new yi(yi.SELF_INTERSECTION,s.getInvalidPoint()),null;s.hasDuplicateRings()&&(this.yi=new yi(yi.DUPLICATE_RINGS,s.getInvalidPoint()))}isValid(){return this.checkValid(this.pi),null===this.yi}checkShellInsideHole(t,s,i){const e=t.getCoordinates(),n=s.getCoordinates(),r=bi.findPtNotNode(e,s,i);if(null!==r&&!Xt.isInRing(r,n))return r;const h=bi.findPtNotNode(n,t,i);return null!==h?Xt.isInRing(h,e)?h:null:(a.shouldNeverReachHere("points in shell and hole appear to be equal"),null)}checkNoSelfIntersectingRings(t){for(let s=t.getEdgeIterator();s.hasNext();){const t=s.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this.yi)return null}}checkHolesInShell(t,s){if(t.getNumInteriorRing()<=0)return null;const i=t.getExteriorRing(),e=i.isEmpty(),n=new Vs(i);for(let r=0;r<t.getNumInteriorRing();r++){const h=t.getInteriorRingN(r);let o=null;if(!h.isEmpty()){if(o=bi.findPtNotNode(h.getCoordinates(),i,s),null===o)return null;if(e||qt.EXTERIOR===n.locate(o))return this.yi=new yi(yi.HOLE_OUTSIDE_SHELL,o),null}}}checkShellNotNested(t,s,i){const e=t.getCoordinates(),n=s.getExteriorRing();if(n.isEmpty())return null;const r=n.getCoordinates(),h=bi.findPtNotNode(e,n,i);if(null===h)return null;if(!Xt.isInRing(h,r))return null;if(s.getNumInteriorRing()<=0)return this.yi=new yi(yi.NESTED_SHELLS,h),null;let o=null;for(let u=0;u<s.getNumInteriorRing();u++){const e=s.getInteriorRingN(u);if(o=this.checkShellInsideHole(t,e,i),null===o)return null}this.yi=new yi(yi.NESTED_SHELLS,o)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.yi)return null;for(let s=0;s<t.getNumInteriorRing();s++)if(this.checkClosedRing(t.getInteriorRingN(s)),null!==this.yi)return null}checkConnectedInteriors(t){const s=new Is(t);s.isInteriorsConnected()||(this.yi=new yi(yi.DISCONNECTED_INTERIOR,s.getCoordinate()))}checkNoSelfIntersectingRing(t){const s=new tt;let i=!0;for(let e=t.iterator();e.hasNext();){const t=e.next();if(i)i=!1;else{if(s.contains(t.coord))return this.yi=new yi(yi.RING_SELF_INTERSECTION,t.coord),null;s.add(t.coord)}}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this.yi=new yi(yi.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this.pi),this.yi}checkValid(){if(arguments[0]instanceof pt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Nt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Z){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this.yi)return null;if(this.checkClosedRing(t),null!==this.yi)return null;const s=new $s(0,t);if(this.checkTooFewPoints(s),null!==this.yi)return null;const i=new Yt;s.computeSelfNodes(i,!0,!0),this.checkNoSelfIntersectingRings(s)}else if(arguments[0]instanceof U){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this.yi)return null;const s=new $s(0,t);this.checkTooFewPoints(s)}else if(arguments[0]instanceof Mt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this.yi)return null;if(this.checkClosedRings(t),null!==this.yi)return null;const s=new $s(0,t);if(this.checkTooFewPoints(s),null!==this.yi)return null;if(this.checkConsistentArea(s),null!==this.yi)return null;if(!this.mi&&(this.checkNoSelfIntersectingRings(s),null!==this.yi))return null;if(this.checkHolesInShell(t,s),null!==this.yi)return null;if(this.checkHolesNotNested(t,s),null!==this.yi)return null;this.checkConnectedInteriors(s)}else if(arguments[0]instanceof rt){const t=arguments[0];for(let i=0;i<t.getNumGeometries();i++){const s=t.getGeometryN(i);if(this.checkInvalidCoordinates(s),null!==this.yi)return null;if(this.checkClosedRings(s),null!==this.yi)return null}const s=new $s(0,t);if(this.checkTooFewPoints(s),null!==this.yi)return null;if(this.checkConsistentArea(s),null!==this.yi)return null;if(!this.mi&&(this.checkNoSelfIntersectingRings(s),null!==this.yi))return null;for(let i=0;i<t.getNumGeometries();i++){const e=t.getGeometryN(i);if(this.checkHolesInShell(e,s),null!==this.yi)return null}for(let i=0;i<t.getNumGeometries();i++){const e=t.getGeometryN(i);if(this.checkHolesNotNested(e,s),null!==this.yi)return null}if(this.checkShellsNotNested(t,s),null!==this.yi)return null;this.checkConnectedInteriors(s)}else if(arguments[0]instanceof et){const t=arguments[0];for(let s=0;s<t.getNumGeometries();s++){const i=t.getGeometryN(s);if(this.checkValid(i),null!==this.yi)return null}}else if(arguments[0]instanceof G){const t=arguments[0];if(this.yi=null,t.isEmpty())return null;if(t instanceof pt)this.checkValid(t);else if(t instanceof Nt)this.checkValid(t);else if(t instanceof Z)this.checkValid(t);else if(t instanceof U)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof rt)this.checkValid(t);else{if(!(t instanceof et))throw new E(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this.mi=t}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let s=null;t.getNumPoints()>=1&&(s=t.getCoordinateN(0)),this.yi=new yi(yi.RING_NOT_CLOSED,s)}}checkShellsNotNested(t,s){for(let i=0;i<t.getNumGeometries();i++){const e=t.getGeometryN(i).getExteriorRing();for(let n=0;n<t.getNumGeometries();n++){if(i===n)continue;const r=t.getGeometryN(n);if(this.checkShellNotNested(e,r,s),null!==this.yi)return null}}}}export{bi as I,kt as W};
